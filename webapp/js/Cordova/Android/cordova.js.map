{"version":3,"names":[],"mappings":"","sources":["js/Cordova/Android/cordova.js"],"sourcesContent":["// Platform: android\n// ???\n// browserify\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n * \n *     http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nvar PLATFORM_VERSION_BUILD_LABEL = '5.2.1';\nvar define = {moduleMap: []};\nrequire=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\nrequire('cordova/init');\n\n},{\"cordova/init\":\"cordova/init\"}],\"cordova-plugin-camera.CameraPopoverHandle\":[function(require,module,exports){\n/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n/**\n * @ignore in favour of iOS' one\n * A handle to an image picker popover.\n */\nvar CameraPopoverHandle = function() {\n    this.setPosition = function(popoverOptions) {\n        console.log('CameraPopoverHandle.setPosition is only supported on iOS.');\n    };\n};\n\nmodule.exports = CameraPopoverHandle;\n\n},{}],\"cordova-plugin-camera.CameraPopoverOptions\":[function(require,module,exports){\n/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\nvar Camera = require('cordova-plugin-camera.Camera');\n\n/** \n * @namespace navigator\n */\n\n/**\n * iOS-only parameters that specify the anchor element location and arrow\n * direction of the popover when selecting images from an iPad's library\n * or album.\n * Note that the size of the popover may change to adjust to the\n * direction of the arrow and orientation of the screen.  Make sure to\n * account for orientation changes when specifying the anchor element\n * location.\n * @module CameraPopoverOptions\n * @param {Number} [x=0] - x pixel coordinate of screen element onto which to anchor the popover.\n * @param {Number} [y=32] - y pixel coordinate of screen element onto which to anchor the popover.\n * @param {Number} [width=320] - width, in pixels, of the screen element onto which to anchor the popover.\n * @param {Number} [height=480] - height, in pixels, of the screen element onto which to anchor the popover.\n * @param {module:Camera.PopoverArrowDirection} [arrowDir=ARROW_ANY] - Direction the arrow on the popover should point.\n */\nvar CameraPopoverOptions = function (x, y, width, height, arrowDir) {\n    // information of rectangle that popover should be anchored to\n    this.x = x || 0;\n    this.y = y || 32;\n    this.width = width || 320;\n    this.height = height || 480;\n    this.arrowDir = arrowDir || Camera.PopoverArrowDirection.ARROW_ANY;\n};\n\nmodule.exports = CameraPopoverOptions;\n\n},{\"cordova-plugin-camera.Camera\":\"cordova-plugin-camera.Camera\"}],\"cordova-plugin-camera.Camera\":[function(require,module,exports){\n/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n/**\n * @module Camera\n */\nmodule.exports = {\n  /**\n   * @enum {number}\n   */\n  DestinationType:{\n    /** Return base64 encoded string. DATA_URL can be very memory intensive and cause app crashes or out of memory errors. Use FILE_URI or NATIVE_URI if possible */\n    DATA_URL: 0,\n    /** Return file uri (content://media/external/images/media/2 for Android) */\n    FILE_URI: 1,\n    /** Return native uri (eg. asset-library://... for iOS) */\n    NATIVE_URI: 2\n  },\n  /**\n   * @enum {number}\n   */\n  EncodingType:{\n    /** Return JPEG encoded image */\n    JPEG: 0,\n    /** Return PNG encoded image */\n    PNG: 1\n  },\n  /**\n   * @enum {number}\n   */\n  MediaType:{\n    /** Allow selection of still pictures only. DEFAULT. Will return format specified via DestinationType */\n    PICTURE: 0,\n    /** Allow selection of video only, ONLY RETURNS URL */\n    VIDEO: 1,\n    /** Allow selection from all media types */\n    ALLMEDIA : 2\n  },\n  /**\n   * @enum {number}\n   */\n  PictureSourceType:{\n    /** Choose image from picture library (same as SAVEDPHOTOALBUM for Android) */\n    PHOTOLIBRARY : 0,\n    /** Take picture from camera */\n    CAMERA : 1,\n    /** Choose image from picture library (same as PHOTOLIBRARY for Android) */\n    SAVEDPHOTOALBUM : 2\n  },\n  /**\n   * Matches iOS UIPopoverArrowDirection constants to specify arrow location on popover.\n   * @enum {number}\n   */\n  PopoverArrowDirection:{\n      ARROW_UP : 1,\n      ARROW_DOWN : 2,\n      ARROW_LEFT : 4,\n      ARROW_RIGHT : 8,\n      ARROW_ANY : 15\n  },\n  /**\n   * @enum {number}\n   */\n  Direction:{\n      /** Use the back-facing camera */\n      BACK: 0,\n      /** Use the front-facing camera */\n      FRONT: 1\n  }\n};\n\n},{}],\"cordova-plugin-camera.camera\":[function(require,module,exports){\n/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\nvar argscheck = require('cordova/argscheck'),\n    exec = require('cordova/exec'),\n    Camera = require('cordova-plugin-camera.Camera');\n    // XXX: commented out\n    //CameraPopoverHandle = require('./CameraPopoverHandle');\n\n/**\n * @namespace navigator\n */\n\n/**\n * @exports camera\n */\nvar cameraExport = {};\n\n// Tack on the Camera Constants to the base camera plugin.\nfor (var key in Camera) {\n    cameraExport[key] = Camera[key];\n}\n\n/**\n * Callback function that provides an error message.\n * @callback module:camera.onError\n * @param {string} message - The message is provided by the device's native code.\n */\n\n/**\n * Callback function that provides the image data.\n * @callback module:camera.onSuccess\n * @param {string} imageData - Base64 encoding of the image data, _or_ the image file URI, depending on [`cameraOptions`]{@link module:camera.CameraOptions} in effect.\n * @example\n * // Show image\n * //\n * function cameraCallback(imageData) {\n *    var image = document.getElementById('myImage');\n *    image.src = \"data:image/jpeg;base64,\" + imageData;\n * }\n */\n\n/**\n * Optional parameters to customize the camera settings.\n * * [Quirks](#CameraOptions-quirks)\n * @typedef module:camera.CameraOptions\n * @type {Object}\n * @property {number} [quality=50] - Quality of the saved image, expressed as a range of 0-100, where 100 is typically full resolution with no loss from file compression. (Note that information about the camera's resolution is unavailable.)\n * @property {module:Camera.DestinationType} [destinationType=FILE_URI] - Choose the format of the return value.\n * @property {module:Camera.PictureSourceType} [sourceType=CAMERA] - Set the source of the picture.\n * @property {Boolean} [allowEdit=true] - Allow simple editing of image before selection.\n * @property {module:Camera.EncodingType} [encodingType=JPEG] - Choose the  returned image file's encoding.\n * @property {number} [targetWidth] - Width in pixels to scale image. Must be used with `targetHeight`. Aspect ratio remains constant.\n * @property {number} [targetHeight] - Height in pixels to scale image. Must be used with `targetWidth`. Aspect ratio remains constant.\n * @property {module:Camera.MediaType} [mediaType=PICTURE] - Set the type of media to select from.  Only works when `PictureSourceType` is `PHOTOLIBRARY` or `SAVEDPHOTOALBUM`.\n * @property {Boolean} [correctOrientation] - Rotate the image to correct for the orientation of the device during capture.\n * @property {Boolean} [saveToPhotoAlbum] - Save the image to the photo album on the device after capture.\n * @property {module:CameraPopoverOptions} [popoverOptions] - iOS-only options that specify popover location in iPad.\n * @property {module:Camera.Direction} [cameraDirection=BACK] - Choose the camera to use (front- or back-facing).\n */\n\n/**\n * @description Takes a photo using the camera, or retrieves a photo from the device's\n * image gallery.  The image is passed to the success callback as a\n * Base64-encoded `String`, or as the URI for the image file.\n *\n * The `camera.getPicture` function opens the device's default camera\n * application that allows users to snap pictures by default - this behavior occurs,\n * when `Camera.sourceType` equals [`Camera.PictureSourceType.CAMERA`]{@link module:Camera.PictureSourceType}.\n * Once the user snaps the photo, the camera application closes and the application is restored.\n *\n * If `Camera.sourceType` is `Camera.PictureSourceType.PHOTOLIBRARY` or\n * `Camera.PictureSourceType.SAVEDPHOTOALBUM`, then a dialog displays\n * that allows users to select an existing image.  The\n * `camera.getPicture` function returns a [`CameraPopoverHandle`]{@link module:CameraPopoverHandle} object,\n * which can be used to reposition the image selection dialog, for\n * example, when the device orientation changes.\n *\n * The return value is sent to the [`cameraSuccess`]{@link module:camera.onSuccess} callback function, in\n * one of the following formats, depending on the specified\n * `cameraOptions`:\n *\n * - A `String` containing the Base64-encoded photo image.\n *\n * - A `String` representing the image file location on local storage (default).\n *\n * You can do whatever you want with the encoded image or URI, for\n * example:\n *\n * - Render the image in an `<img>` tag, as in the example below\n *\n * - Save the data locally (`LocalStorage`, [Lawnchair](http://brianleroux.github.com/lawnchair/), etc.)\n *\n * - Post the data to a remote server\n *\n * __NOTE__: Photo resolution on newer devices is quite good. Photos\n * selected from the device's gallery are not downscaled to a lower\n * quality, even if a `quality` parameter is specified.  To avoid common\n * memory problems, set `Camera.destinationType` to `FILE_URI` rather\n * than `DATA_URL`.\n *\n * __Supported Platforms__\n *\n * - Android\n * - BlackBerry\n * - Browser\n * - Firefox\n * - FireOS\n * - iOS\n * - Windows\n * - WP8\n * - Ubuntu\n *\n * More examples [here](#camera-getPicture-examples). Quirks [here](#camera-getPicture-quirks).\n *\n * @example\n * navigator.camera.getPicture(cameraSuccess, cameraError, cameraOptions);\n * @param {module:camera.onSuccess} successCallback\n * @param {module:camera.onError} errorCallback\n * @param {module:camera.CameraOptions} options CameraOptions\n */\ncameraExport.getPicture = function(successCallback, errorCallback, options) {\n    argscheck.checkArgs('fFO', 'Camera.getPicture', arguments);\n    options = options || {};\n    var getValue = argscheck.getValue;\n\n    var quality = getValue(options.quality, 50);\n    var destinationType = getValue(options.destinationType, Camera.DestinationType.FILE_URI);\n    var sourceType = getValue(options.sourceType, Camera.PictureSourceType.CAMERA);\n    var targetWidth = getValue(options.targetWidth, -1);\n    var targetHeight = getValue(options.targetHeight, -1);\n    var encodingType = getValue(options.encodingType, Camera.EncodingType.JPEG);\n    var mediaType = getValue(options.mediaType, Camera.MediaType.PICTURE);\n    var allowEdit = !!options.allowEdit;\n    var correctOrientation = !!options.correctOrientation;\n    var saveToPhotoAlbum = !!options.saveToPhotoAlbum;\n    var popoverOptions = getValue(options.popoverOptions, null);\n    var cameraDirection = getValue(options.cameraDirection, Camera.Direction.BACK);\n\n    var args = [quality, destinationType, sourceType, targetWidth, targetHeight, encodingType,\n                mediaType, allowEdit, correctOrientation, saveToPhotoAlbum, popoverOptions, cameraDirection];\n\n    exec(successCallback, errorCallback, \"Camera\", \"takePicture\", args);\n    // XXX: commented out\n    //return new CameraPopoverHandle();\n};\n\n/**\n * Removes intermediate image files that are kept in temporary storage\n * after calling [`camera.getPicture`]{@link module:camera.getPicture}. Applies only when the value of\n * `Camera.sourceType` equals `Camera.PictureSourceType.CAMERA` and the\n * `Camera.destinationType` equals `Camera.DestinationType.FILE_URI`.\n *\n * __Supported Platforms__\n *\n * - iOS\n *\n * @example\n * navigator.camera.cleanup(onSuccess, onFail);\n *\n * function onSuccess() {\n *     console.log(\"Camera cleanup success.\")\n * }\n *\n * function onFail(message) {\n *     alert('Failed because: ' + message);\n * }\n */\ncameraExport.cleanup = function(successCallback, errorCallback) {\n    exec(successCallback, errorCallback, \"Camera\", \"cleanup\", []);\n};\n\nmodule.exports = cameraExport;\n\n},{\"cordova-plugin-camera.Camera\":\"cordova-plugin-camera.Camera\",\"cordova/argscheck\":\"cordova/argscheck\",\"cordova/exec\":\"cordova/exec\"}],\"cordova-plugin-device-orientation.CompassError\":[function(require,module,exports){\n/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n/**\n *  CompassError.\n *  An error code assigned by an implementation when an error has occurred\n * @constructor\n */\nvar CompassError = function(err) {\n    this.code = (err !== undefined ? err : null);\n};\n\nCompassError.COMPASS_INTERNAL_ERR = 0;\nCompassError.COMPASS_NOT_SUPPORTED = 20;\n\nmodule.exports = CompassError;\n\n},{}],\"cordova-plugin-device-orientation.CompassHeading\":[function(require,module,exports){\n/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\nvar CompassHeading = function(magneticHeading, trueHeading, headingAccuracy, timestamp) {\n  this.magneticHeading = magneticHeading;\n  this.trueHeading = trueHeading;\n  this.headingAccuracy = headingAccuracy;\n  this.timestamp = timestamp || new Date().getTime();\n};\n\nmodule.exports = CompassHeading;\n\n},{}],\"cordova-plugin-device-orientation.compass\":[function(require,module,exports){\n/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\nvar argscheck = require('cordova/argscheck'),\n    exec = require('cordova/exec'),\n    utils = require('cordova/utils'),\n    CompassHeading = require('cordova-plugin-device-orientation.CompassHeading'),\n    CompassError = require('cordova-plugin-device-orientation.CompassError'),\n\n    timers = {},\n    eventTimerId = null,\n    compass = {\n        /**\n         * Asynchronously acquires the current heading.\n         * @param {Function} successCallback The function to call when the heading\n         * data is available\n         * @param {Function} errorCallback The function to call when there is an error\n         * getting the heading data.\n         * @param {CompassOptions} options The options for getting the heading data (not used).\n         */\n        getCurrentHeading:function(successCallback, errorCallback, options) {\n            argscheck.checkArgs('fFO', 'compass.getCurrentHeading', arguments);\n\n            var win = function(result) {\n                var ch = new CompassHeading(result.magneticHeading, result.trueHeading, result.headingAccuracy, result.timestamp);\n                successCallback(ch);\n            };\n            var fail = errorCallback && function(code) {\n                var ce = new CompassError(code);\n                errorCallback(ce);\n            };\n\n            // Get heading\n            exec(win, fail, \"Compass\", \"getHeading\", [options]);\n        },\n\n        /**\n         * Asynchronously acquires the heading repeatedly at a given interval.\n         * @param {Function} successCallback The function to call each time the heading\n         * data is available\n         * @param {Function} errorCallback The function to call when there is an error\n         * getting the heading data.\n         * @param {HeadingOptions} options The options for getting the heading data\n         * such as timeout and the frequency of the watch. For iOS, filter parameter\n         * specifies to watch via a distance filter rather than time.\n         */\n        watchHeading:function(successCallback, errorCallback, options) {\n            argscheck.checkArgs('fFO', 'compass.watchHeading', arguments);\n            // Default interval (100 msec)\n            var frequency = (options !== undefined && options.frequency !== undefined) ? options.frequency : 100;\n            var filter = (options !== undefined && options.filter !== undefined) ? options.filter : 0;\n\n            var id = utils.createUUID();\n            if (filter > 0) {\n                // is an iOS request for watch by filter, no timer needed\n                timers[id] = \"iOS\";\n                compass.getCurrentHeading(successCallback, errorCallback, options);\n            } else {\n                // Start watch timer to get headings\n                timers[id] = window.setInterval(function() {\n                    compass.getCurrentHeading(successCallback, errorCallback);\n                }, frequency);\n            }\n\n            if (cordova.platformId === 'browser' && !eventTimerId) {\n                // Start firing deviceorientation events if haven't already\n                var deviceorientationEvent = new Event('deviceorientation');\n                eventTimerId = window.setInterval(function() {\n                    window.dispatchEvent(deviceorientationEvent);\n                }, 200);\n            }\n\n            return id;\n        },\n\n        /**\n         * Clears the specified heading watch.\n         * @param {String} id The ID of the watch returned from #watchHeading.\n         */\n        clearWatch:function(id) {\n            // Stop javascript timer & remove from timer list\n            if (id && timers[id]) {\n                if (timers[id] != \"iOS\") {\n                    clearInterval(timers[id]);\n                } else {\n                    // is iOS watch by filter so call into device to stop\n                    exec(null, null, \"Compass\", \"stopHeading\", []);\n                }\n                delete timers[id];\n\n                if (eventTimerId && Object.keys(timers).length === 0) {\n                    // No more watchers, so stop firing 'deviceorientation' events\n                    window.clearInterval(eventTimerId);\n                    eventTimerId = null;\n                }\n            }\n        }\n    };\n\nmodule.exports = compass;\n\n},{\"cordova-plugin-device-orientation.CompassError\":\"cordova-plugin-device-orientation.CompassError\",\"cordova-plugin-device-orientation.CompassHeading\":\"cordova-plugin-device-orientation.CompassHeading\",\"cordova/argscheck\":\"cordova/argscheck\",\"cordova/exec\":\"cordova/exec\",\"cordova/utils\":\"cordova/utils\"}],\"cordova-plugin-device.device\":[function(require,module,exports){\n/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\nvar argscheck = require('cordova/argscheck'),\n    channel = require('cordova/channel'),\n    utils = require('cordova/utils'),\n    exec = require('cordova/exec'),\n    cordova = require('cordova');\n\nchannel.createSticky('onCordovaInfoReady');\n// Tell cordova channel to wait on the CordovaInfoReady event\nchannel.waitForInitialization('onCordovaInfoReady');\n\n/**\n * This represents the mobile device, and provides properties for inspecting the model, version, UUID of the\n * phone, etc.\n * @constructor\n */\nfunction Device() {\n    this.available = false;\n    this.platform = null;\n    this.version = null;\n    this.uuid = null;\n    this.cordova = null;\n    this.model = null;\n    this.manufacturer = null;\n    this.isVirtual = null;\n    this.serial = null;\n\n    var me = this;\n\n    channel.onCordovaReady.subscribe(function() {\n        me.getInfo(function(info) {\n            //ignoring info.cordova returning from native, we should use value from cordova.version defined in cordova.js\n            //TODO: CB-5105 native implementations should not return info.cordova\n            var buildLabel = cordova.version;\n            me.available = true;\n            me.platform = info.platform;\n            me.version = info.version;\n            me.uuid = info.uuid;\n            me.cordova = buildLabel;\n            me.model = info.model;\n            me.isVirtual = info.isVirtual;\n            me.manufacturer = info.manufacturer || 'unknown';\n            me.serial = info.serial || 'unknown';\n            channel.onCordovaInfoReady.fire();\n        },function(e) {\n            me.available = false;\n            utils.alert(\"[ERROR] Error initializing Cordova: \" + e);\n        });\n    });\n}\n\n/**\n * Get device info\n *\n * @param {Function} successCallback The function to call when the heading data is available\n * @param {Function} errorCallback The function to call when there is an error getting the heading data. (OPTIONAL)\n */\nDevice.prototype.getInfo = function(successCallback, errorCallback) {\n    argscheck.checkArgs('fF', 'Device.getInfo', arguments);\n    exec(successCallback, errorCallback, \"Device\", \"getDeviceInfo\", []);\n};\n\nmodule.exports = new Device();\n\n},{\"cordova\":\"cordova\",\"cordova/argscheck\":\"cordova/argscheck\",\"cordova/channel\":\"cordova/channel\",\"cordova/exec\":\"cordova/exec\",\"cordova/utils\":\"cordova/utils\"}],\"cordova-plugin-file-transfer.FileTransferError\":[function(require,module,exports){\n/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n/**\n * FileTransferError\n * @constructor\n */\nvar FileTransferError = function(code, source, target, status, body, exception) {\n    this.code = code || null;\n    this.source = source || null;\n    this.target = target || null;\n    this.http_status = status || null;\n    this.body = body || null;\n    this.exception = exception || null;\n};\n\nFileTransferError.FILE_NOT_FOUND_ERR = 1;\nFileTransferError.INVALID_URL_ERR = 2;\nFileTransferError.CONNECTION_ERR = 3;\nFileTransferError.ABORT_ERR = 4;\nFileTransferError.NOT_MODIFIED_ERR = 5;\n\nmodule.exports = FileTransferError;\n\n},{}],\"cordova-plugin-file-transfer.FileTransfer\":[function(require,module,exports){\n/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n/* global cordova, FileSystem */\n\nvar argscheck = require('cordova/argscheck'),\n    exec = require('cordova/exec'),\n    FileTransferError = require('cordova-plugin-file-transfer.FileTransferError'),\n    ProgressEvent = require('cordova-plugin-file.ProgressEvent');\n\nfunction newProgressEvent(result) {\n    var pe = new ProgressEvent();\n    pe.lengthComputable = result.lengthComputable;\n    pe.loaded = result.loaded;\n    pe.total = result.total;\n    return pe;\n}\n\nfunction getUrlCredentials(urlString) {\n    var credentialsPattern = /^https?\\:\\/\\/(?:(?:(([^:@\\/]*)(?::([^@\\/]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?).*$/,\n        credentials = credentialsPattern.exec(urlString);\n\n    return credentials && credentials[1];\n}\n\nfunction getBasicAuthHeader(urlString) {\n    var header =  null;\n\n\n    // This is changed due to MS Windows doesn't support credentials in http uris\n    // so we detect them by regexp and strip off from result url\n    // Proof: http://social.msdn.microsoft.com/Forums/windowsapps/en-US/a327cf3c-f033-4a54-8b7f-03c56ba3203f/windows-foundation-uri-security-problem\n\n    if (window.btoa) {\n        var credentials = getUrlCredentials(urlString);\n        if (credentials) {\n            var authHeader = \"Authorization\";\n            var authHeaderValue = \"Basic \" + window.btoa(credentials);\n\n            header = {\n                name : authHeader,\n                value : authHeaderValue\n            };\n        }\n    }\n\n    return header;\n}\n\nfunction convertHeadersToArray(headers) {\n    var result = [];\n    for (var header in headers) {\n        if (headers.hasOwnProperty(header)) {\n            var headerValue = headers[header];\n            result.push({\n                name: header,\n                value: headerValue.toString()\n            });\n        }\n    }\n    return result;\n}\n\nvar idCounter = 0;\n\n/**\n * FileTransfer uploads a file to a remote server.\n * @constructor\n */\nvar FileTransfer = function() {\n    this._id = ++idCounter;\n    this.onprogress = null; // optional callback\n};\n\n/**\n* Given an absolute file path, uploads a file on the device to a remote server\n* using a multipart HTTP request.\n* @param filePath {String}           Full path of the file on the device\n* @param server {String}             URL of the server to receive the file\n* @param successCallback (Function}  Callback to be invoked when upload has completed\n* @param errorCallback {Function}    Callback to be invoked upon error\n* @param options {FileUploadOptions} Optional parameters such as file name and mimetype\n* @param trustAllHosts {Boolean} Optional trust all hosts (e.g. for self-signed certs), defaults to false\n*/\nFileTransfer.prototype.upload = function(filePath, server, successCallback, errorCallback, options, trustAllHosts) {\n    argscheck.checkArgs('ssFFO*', 'FileTransfer.upload', arguments);\n    // check for options\n    var fileKey = null;\n    var fileName = null;\n    var mimeType = null;\n    var params = null;\n    var chunkedMode = true;\n    var headers = null;\n    var httpMethod = null;\n    var basicAuthHeader = getBasicAuthHeader(server);\n    if (basicAuthHeader) {\n        server = server.replace(getUrlCredentials(server) + '@', '');\n\n        options = options || {};\n        options.headers = options.headers || {};\n        options.headers[basicAuthHeader.name] = basicAuthHeader.value;\n    }\n\n    if (options) {\n        fileKey = options.fileKey;\n        fileName = options.fileName;\n        mimeType = options.mimeType;\n        headers = options.headers;\n        httpMethod = options.httpMethod || \"POST\";\n        if (httpMethod.toUpperCase() == \"PUT\"){\n            httpMethod = \"PUT\";\n        } else {\n            httpMethod = \"POST\";\n        }\n        if (options.chunkedMode !== null || typeof options.chunkedMode != \"undefined\") {\n            chunkedMode = options.chunkedMode;\n        }\n        if (options.params) {\n            params = options.params;\n        }\n        else {\n            params = {};\n        }\n    }\n\n    if (cordova.platformId === \"windowsphone\") {\n        headers = headers && convertHeadersToArray(headers);\n        params = params && convertHeadersToArray(params);\n    }\n\n    var fail = errorCallback && function(e) {\n        var error = new FileTransferError(e.code, e.source, e.target, e.http_status, e.body, e.exception);\n        errorCallback(error);\n    };\n\n    var self = this;\n    var win = function(result) {\n        if (typeof result.lengthComputable != \"undefined\") {\n            if (self.onprogress) {\n                self.onprogress(newProgressEvent(result));\n            }\n        } else {\n            if (successCallback) {\n                successCallback(result);\n            }\n        }\n    };\n    exec(win, fail, 'FileTransfer', 'upload', [filePath, server, fileKey, fileName, mimeType, params, trustAllHosts, chunkedMode, headers, this._id, httpMethod]);\n};\n\n/**\n * Downloads a file form a given URL and saves it to the specified directory.\n * @param source {String}          URL of the server to receive the file\n * @param target {String}         Full path of the file on the device\n * @param successCallback (Function}  Callback to be invoked when upload has completed\n * @param errorCallback {Function}    Callback to be invoked upon error\n * @param trustAllHosts {Boolean} Optional trust all hosts (e.g. for self-signed certs), defaults to false\n * @param options {FileDownloadOptions} Optional parameters such as headers\n */\nFileTransfer.prototype.download = function(source, target, successCallback, errorCallback, trustAllHosts, options) {\n    argscheck.checkArgs('ssFF*', 'FileTransfer.download', arguments);\n    var self = this;\n\n    var basicAuthHeader = getBasicAuthHeader(source);\n    if (basicAuthHeader) {\n        source = source.replace(getUrlCredentials(source) + '@', '');\n\n        options = options || {};\n        options.headers = options.headers || {};\n        options.headers[basicAuthHeader.name] = basicAuthHeader.value;\n    }\n\n    var headers = null;\n    if (options) {\n        headers = options.headers || null;\n    }\n\n    if (cordova.platformId === \"windowsphone\" && headers) {\n        headers = convertHeadersToArray(headers);\n    }\n\n    var win = function(result) {\n        if (typeof result.lengthComputable != \"undefined\") {\n            if (self.onprogress) {\n                return self.onprogress(newProgressEvent(result));\n            }\n        } else if (successCallback) {\n            var entry = null;\n            if (result.isDirectory) {\n                entry = new (require('cordova-plugin-file.DirectoryEntry'))();\n            }\n            else if (result.isFile) {\n                entry = new (require('cordova-plugin-file.FileEntry'))();\n            }\n            entry.isDirectory = result.isDirectory;\n            entry.isFile = result.isFile;\n            entry.name = result.name;\n            entry.fullPath = result.fullPath;\n            entry.filesystem = new FileSystem(result.filesystemName || (result.filesystem == window.PERSISTENT ? 'persistent' : 'temporary'));\n            entry.nativeURL = result.nativeURL;\n            successCallback(entry);\n        }\n    };\n\n    var fail = errorCallback && function(e) {\n        var error = new FileTransferError(e.code, e.source, e.target, e.http_status, e.body, e.exception);\n        errorCallback(error);\n    };\n\n    exec(win, fail, 'FileTransfer', 'download', [source, target, trustAllHosts, this._id, headers]);\n};\n\n/**\n * Aborts the ongoing file transfer on this object. The original error\n * callback for the file transfer will be called if necessary.\n */\nFileTransfer.prototype.abort = function() {\n    exec(null, null, 'FileTransfer', 'abort', [this._id]);\n};\n\nmodule.exports = FileTransfer;\n\n},{\"cordova-plugin-file-transfer.FileTransferError\":\"cordova-plugin-file-transfer.FileTransferError\",\"cordova-plugin-file.DirectoryEntry\":\"cordova-plugin-file.DirectoryEntry\",\"cordova-plugin-file.FileEntry\":\"cordova-plugin-file.FileEntry\",\"cordova-plugin-file.ProgressEvent\":\"cordova-plugin-file.ProgressEvent\",\"cordova/argscheck\":\"cordova/argscheck\",\"cordova/exec\":\"cordova/exec\"}],\"cordova-plugin-file.DirectoryEntry\":[function(require,module,exports){\n/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\nvar argscheck = require('cordova/argscheck'),\n    utils = require('cordova/utils'),\n    exec = require('cordova/exec'),\n    Entry = require('cordova-plugin-file.Entry'),\n    FileError = require('cordova-plugin-file.FileError'),\n    DirectoryReader = require('cordova-plugin-file.DirectoryReader');\n\n/**\n * An interface representing a directory on the file system.\n *\n * {boolean} isFile always false (readonly)\n * {boolean} isDirectory always true (readonly)\n * {DOMString} name of the directory, excluding the path leading to it (readonly)\n * {DOMString} fullPath the absolute full path to the directory (readonly)\n * {FileSystem} filesystem on which the directory resides (readonly)\n */\nvar DirectoryEntry = function(name, fullPath, fileSystem, nativeURL) {\n\n    // add trailing slash if it is missing\n    if ((fullPath) && !/\\/$/.test(fullPath)) {\n        fullPath += \"/\";\n    }\n    // add trailing slash if it is missing\n    if (nativeURL && !/\\/$/.test(nativeURL)) {\n        nativeURL += \"/\";\n    }\n    DirectoryEntry.__super__.constructor.call(this, false, true, name, fullPath, fileSystem, nativeURL);\n};\n\nutils.extend(DirectoryEntry, Entry);\n\n/**\n * Creates a new DirectoryReader to read entries from this directory\n */\nDirectoryEntry.prototype.createReader = function() {\n    return new DirectoryReader(this.toInternalURL());\n};\n\n/**\n * Creates or looks up a directory\n *\n * @param {DOMString} path either a relative or absolute path from this directory in which to look up or create a directory\n * @param {Flags} options to create or exclusively create the directory\n * @param {Function} successCallback is called with the new entry\n * @param {Function} errorCallback is called with a FileError\n */\nDirectoryEntry.prototype.getDirectory = function(path, options, successCallback, errorCallback) {\n    argscheck.checkArgs('sOFF', 'DirectoryEntry.getDirectory', arguments);\n    var fs = this.filesystem;\n    var win = successCallback && function(result) {\n        var entry = new DirectoryEntry(result.name, result.fullPath, fs, result.nativeURL);\n        successCallback(entry);\n    };\n    var fail = errorCallback && function(code) {\n        errorCallback(new FileError(code));\n    };\n    exec(win, fail, \"File\", \"getDirectory\", [this.toInternalURL(), path, options]);\n};\n\n/**\n * Deletes a directory and all of it's contents\n *\n * @param {Function} successCallback is called with no parameters\n * @param {Function} errorCallback is called with a FileError\n */\nDirectoryEntry.prototype.removeRecursively = function(successCallback, errorCallback) {\n    argscheck.checkArgs('FF', 'DirectoryEntry.removeRecursively', arguments);\n    var fail = errorCallback && function(code) {\n        errorCallback(new FileError(code));\n    };\n    exec(successCallback, fail, \"File\", \"removeRecursively\", [this.toInternalURL()]);\n};\n\n/**\n * Creates or looks up a file\n *\n * @param {DOMString} path either a relative or absolute path from this directory in which to look up or create a file\n * @param {Flags} options to create or exclusively create the file\n * @param {Function} successCallback is called with the new entry\n * @param {Function} errorCallback is called with a FileError\n */\nDirectoryEntry.prototype.getFile = function(path, options, successCallback, errorCallback) {\n    argscheck.checkArgs('sOFF', 'DirectoryEntry.getFile', arguments);\n    var fs = this.filesystem;\n    var win = successCallback && function(result) {\n        var FileEntry = require('cordova-plugin-file.FileEntry');\n        var entry = new FileEntry(result.name, result.fullPath, fs, result.nativeURL);\n        successCallback(entry);\n    };\n    var fail = errorCallback && function(code) {\n        errorCallback(new FileError(code));\n    };\n    exec(win, fail, \"File\", \"getFile\", [this.toInternalURL(), path, options]);\n};\n\nmodule.exports = DirectoryEntry;\n\n},{\"cordova-plugin-file.DirectoryReader\":\"cordova-plugin-file.DirectoryReader\",\"cordova-plugin-file.Entry\":\"cordova-plugin-file.Entry\",\"cordova-plugin-file.FileEntry\":\"cordova-plugin-file.FileEntry\",\"cordova-plugin-file.FileError\":\"cordova-plugin-file.FileError\",\"cordova/argscheck\":\"cordova/argscheck\",\"cordova/exec\":\"cordova/exec\",\"cordova/utils\":\"cordova/utils\"}],\"cordova-plugin-file.DirectoryReader\":[function(require,module,exports){\n/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\nvar exec = require('cordova/exec'),\n    FileError = require('cordova-plugin-file.FileError') ;\n\n/**\n * An interface that lists the files and directories in a directory.\n */\nfunction DirectoryReader(localURL) {\n    this.localURL = localURL || null;\n    this.hasReadEntries = false;\n}\n\n/**\n * Returns a list of entries from a directory.\n *\n * @param {Function} successCallback is called with a list of entries\n * @param {Function} errorCallback is called with a FileError\n */\nDirectoryReader.prototype.readEntries = function(successCallback, errorCallback) {\n    // If we've already read and passed on this directory's entries, return an empty list.\n    if (this.hasReadEntries) {\n        successCallback([]);\n        return;\n    }\n    var reader = this;\n    var win = typeof successCallback !== 'function' ? null : function(result) {\n        var retVal = [];\n        for (var i=0; i<result.length; i++) {\n            var entry = null;\n            if (result[i].isDirectory) {\n                entry = new (require('cordova-plugin-file.DirectoryEntry'))();\n            }\n            else if (result[i].isFile) {\n                entry = new (require('cordova-plugin-file.FileEntry'))();\n            }\n            entry.isDirectory = result[i].isDirectory;\n            entry.isFile = result[i].isFile;\n            entry.name = result[i].name;\n            entry.fullPath = result[i].fullPath;\n            entry.filesystem = new (require('cordova-plugin-file.FileSystem'))(result[i].filesystemName);\n            entry.nativeURL = result[i].nativeURL;\n            retVal.push(entry);\n        }\n        reader.hasReadEntries = true;\n        successCallback(retVal);\n    };\n    var fail = typeof errorCallback !== 'function' ? null : function(code) {\n        errorCallback(new FileError(code));\n    };\n    exec(win, fail, \"File\", \"readEntries\", [this.localURL]);\n};\n\nmodule.exports = DirectoryReader;\n\n},{\"cordova-plugin-file.DirectoryEntry\":\"cordova-plugin-file.DirectoryEntry\",\"cordova-plugin-file.FileEntry\":\"cordova-plugin-file.FileEntry\",\"cordova-plugin-file.FileError\":\"cordova-plugin-file.FileError\",\"cordova-plugin-file.FileSystem\":\"cordova-plugin-file.FileSystem\",\"cordova/exec\":\"cordova/exec\"}],\"cordova-plugin-file.Entry\":[function(require,module,exports){\n/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\nvar argscheck = require('cordova/argscheck'),\n    exec = require('cordova/exec'),\n    FileError = require('cordova-plugin-file.FileError'),\n    Metadata = require('cordova-plugin-file.Metadata');\n\n/**\n * Represents a file or directory on the local file system.\n *\n * @param isFile\n *            {boolean} true if Entry is a file (readonly)\n * @param isDirectory\n *            {boolean} true if Entry is a directory (readonly)\n * @param name\n *            {DOMString} name of the file or directory, excluding the path\n *            leading to it (readonly)\n * @param fullPath\n *            {DOMString} the absolute full path to the file or directory\n *            (readonly)\n * @param fileSystem\n *            {FileSystem} the filesystem on which this entry resides\n *            (readonly)\n * @param nativeURL\n *            {DOMString} an alternate URL which can be used by native\n *            webview controls, for example media players.\n *            (optional, readonly)\n */\nfunction Entry(isFile, isDirectory, name, fullPath, fileSystem, nativeURL) {\n    this.isFile = !!isFile;\n    this.isDirectory = !!isDirectory;\n    this.name = name || '';\n    this.fullPath = fullPath || '';\n    this.filesystem = fileSystem || null;\n    this.nativeURL = nativeURL || null;\n}\n\n/**\n * Look up the metadata of the entry.\n *\n * @param successCallback\n *            {Function} is called with a Metadata object\n * @param errorCallback\n *            {Function} is called with a FileError\n */\nEntry.prototype.getMetadata = function(successCallback, errorCallback) {\n    argscheck.checkArgs('FF', 'Entry.getMetadata', arguments);\n    var success = successCallback && function(entryMetadata) {\n        var metadata = new Metadata({\n            size: entryMetadata.size,\n            modificationTime: entryMetadata.lastModifiedDate\n        });\n        successCallback(metadata);\n    };\n    var fail = errorCallback && function(code) {\n        errorCallback(new FileError(code));\n    };\n    exec(success, fail, \"File\", \"getFileMetadata\", [this.toInternalURL()]);\n};\n\n/**\n * Set the metadata of the entry.\n *\n * @param successCallback\n *            {Function} is called with a Metadata object\n * @param errorCallback\n *            {Function} is called with a FileError\n * @param metadataObject\n *            {Object} keys and values to set\n */\nEntry.prototype.setMetadata = function(successCallback, errorCallback, metadataObject) {\n    argscheck.checkArgs('FFO', 'Entry.setMetadata', arguments);\n    exec(successCallback, errorCallback, \"File\", \"setMetadata\", [this.toInternalURL(), metadataObject]);\n};\n\n/**\n * Move a file or directory to a new location.\n *\n * @param parent\n *            {DirectoryEntry} the directory to which to move this entry\n * @param newName\n *            {DOMString} new name of the entry, defaults to the current name\n * @param successCallback\n *            {Function} called with the new DirectoryEntry object\n * @param errorCallback\n *            {Function} called with a FileError\n */\nEntry.prototype.moveTo = function(parent, newName, successCallback, errorCallback) {\n    argscheck.checkArgs('oSFF', 'Entry.moveTo', arguments);\n    var fail = errorCallback && function(code) {\n        errorCallback(new FileError(code));\n    };\n    var srcURL = this.toInternalURL(),\n        // entry name\n        name = newName || this.name,\n        success = function(entry) {\n            if (entry) {\n                if (successCallback) {\n                    // create appropriate Entry object\n                    var newFSName = entry.filesystemName || (entry.filesystem && entry.filesystem.name);\n                    var fs = newFSName ? new FileSystem(newFSName, { name: \"\", fullPath: \"/\" }) : new FileSystem(parent.filesystem.name, { name: \"\", fullPath: \"/\" });\n                    var result = (entry.isDirectory) ? new (require('cordova-plugin-file.DirectoryEntry'))(entry.name, entry.fullPath, fs, entry.nativeURL) : new (require('cordova-plugin-file.FileEntry'))(entry.name, entry.fullPath, fs, entry.nativeURL);\n                    successCallback(result);\n                }\n            }\n            else {\n                // no Entry object returned\n                if (fail) {\n                    fail(FileError.NOT_FOUND_ERR);\n                }\n            }\n        };\n\n    // copy\n    exec(success, fail, \"File\", \"moveTo\", [srcURL, parent.toInternalURL(), name]);\n};\n\n/**\n * Copy a directory to a different location.\n *\n * @param parent\n *            {DirectoryEntry} the directory to which to copy the entry\n * @param newName\n *            {DOMString} new name of the entry, defaults to the current name\n * @param successCallback\n *            {Function} called with the new Entry object\n * @param errorCallback\n *            {Function} called with a FileError\n */\nEntry.prototype.copyTo = function(parent, newName, successCallback, errorCallback) {\n    argscheck.checkArgs('oSFF', 'Entry.copyTo', arguments);\n    var fail = errorCallback && function(code) {\n        errorCallback(new FileError(code));\n    };\n    var srcURL = this.toInternalURL(),\n        // entry name\n        name = newName || this.name,\n        // success callback\n        success = function(entry) {\n            if (entry) {\n                if (successCallback) {\n                    // create appropriate Entry object\n                    var newFSName = entry.filesystemName || (entry.filesystem && entry.filesystem.name);\n                    var fs = newFSName ? new FileSystem(newFSName, { name: \"\", fullPath: \"/\" }) : new FileSystem(parent.filesystem.name, { name: \"\", fullPath: \"/\" });\n                    var result = (entry.isDirectory) ? new (require('cordova-plugin-file.DirectoryEntry'))(entry.name, entry.fullPath, fs, entry.nativeURL) : new (require('cordova-plugin-file.FileEntry'))(entry.name, entry.fullPath, fs, entry.nativeURL);\n                    successCallback(result);\n                }\n            }\n            else {\n                // no Entry object returned\n                if (fail) {\n                    fail(FileError.NOT_FOUND_ERR);\n                }\n            }\n        };\n\n    // copy\n    exec(success, fail, \"File\", \"copyTo\", [srcURL, parent.toInternalURL(), name]);\n};\n\n/**\n * Return a URL that can be passed across the bridge to identify this entry.\n */\nEntry.prototype.toInternalURL = function() {\n    if (this.filesystem && this.filesystem.__format__) {\n      return this.filesystem.__format__(this.fullPath, this.nativeURL);\n    }\n};\n\n/**\n * Return a URL that can be used to identify this entry.\n * Use a URL that can be used to as the src attribute of a <video> or\n * <audio> tag. If that is not possible, construct a cdvfile:// URL.\n */\nEntry.prototype.toURL = function() {\n    if (this.nativeURL) {\n      return this.nativeURL;\n    }\n    // fullPath attribute may contain the full URL in the case that\n    // toInternalURL fails.\n    return this.toInternalURL() || \"file://localhost\" + this.fullPath;\n};\n\n/**\n * Backwards-compatibility: In v1.0.0 - 1.0.2, .toURL would only return a\n * cdvfile:// URL, and this method was necessary to obtain URLs usable by the\n * webview.\n * See CB-6051, CB-6106, CB-6117, CB-6152, CB-6199, CB-6201, CB-6243, CB-6249,\n * and CB-6300.\n */\nEntry.prototype.toNativeURL = function() {\n    console.log(\"DEPRECATED: Update your code to use 'toURL'\");\n    return this.toURL();\n};\n\n/**\n * Returns a URI that can be used to identify this entry.\n *\n * @param {DOMString} mimeType for a FileEntry, the mime type to be used to interpret the file, when loaded through this URI.\n * @return uri\n */\nEntry.prototype.toURI = function(mimeType) {\n    console.log(\"DEPRECATED: Update your code to use 'toURL'\");\n    return this.toURL();\n};\n\n/**\n * Remove a file or directory. It is an error to attempt to delete a\n * directory that is not empty. It is an error to attempt to delete a\n * root directory of a file system.\n *\n * @param successCallback {Function} called with no parameters\n * @param errorCallback {Function} called with a FileError\n */\nEntry.prototype.remove = function(successCallback, errorCallback) {\n    argscheck.checkArgs('FF', 'Entry.remove', arguments);\n    var fail = errorCallback && function(code) {\n        errorCallback(new FileError(code));\n    };\n    exec(successCallback, fail, \"File\", \"remove\", [this.toInternalURL()]);\n};\n\n/**\n * Look up the parent DirectoryEntry of this entry.\n *\n * @param successCallback {Function} called with the parent DirectoryEntry object\n * @param errorCallback {Function} called with a FileError\n */\nEntry.prototype.getParent = function(successCallback, errorCallback) {\n    argscheck.checkArgs('FF', 'Entry.getParent', arguments);\n    var fs = this.filesystem;\n    var win = successCallback && function(result) {\n        var DirectoryEntry = require('cordova-plugin-file.DirectoryEntry');\n        var entry = new DirectoryEntry(result.name, result.fullPath, fs, result.nativeURL);\n        successCallback(entry);\n    };\n    var fail = errorCallback && function(code) {\n        errorCallback(new FileError(code));\n    };\n    exec(win, fail, \"File\", \"getParent\", [this.toInternalURL()]);\n};\n\nmodule.exports = Entry;\n\n},{\"cordova-plugin-file.DirectoryEntry\":\"cordova-plugin-file.DirectoryEntry\",\"cordova-plugin-file.FileEntry\":\"cordova-plugin-file.FileEntry\",\"cordova-plugin-file.FileError\":\"cordova-plugin-file.FileError\",\"cordova-plugin-file.Metadata\":\"cordova-plugin-file.Metadata\",\"cordova/argscheck\":\"cordova/argscheck\",\"cordova/exec\":\"cordova/exec\"}],\"cordova-plugin-file.FileEntry\":[function(require,module,exports){\n/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\nvar utils = require('cordova/utils'),\n    exec = require('cordova/exec'),\n    Entry = require('cordova-plugin-file.Entry'),\n    FileWriter = require('cordova-plugin-file.FileWriter'),\n    File = require('cordova-plugin-file.File'),\n    FileError = require('cordova-plugin-file.FileError');\n\n/**\n * An interface representing a file on the file system.\n *\n * {boolean} isFile always true (readonly)\n * {boolean} isDirectory always false (readonly)\n * {DOMString} name of the file, excluding the path leading to it (readonly)\n * {DOMString} fullPath the absolute full path to the file (readonly)\n * {FileSystem} filesystem on which the file resides (readonly)\n */\nvar FileEntry = function(name, fullPath, fileSystem, nativeURL) {\n    // remove trailing slash if it is present\n    if (fullPath && /\\/$/.test(fullPath)) {\n        fullPath = fullPath.substring(0, fullPath.length - 1);\n    }\n    if (nativeURL && /\\/$/.test(nativeURL)) {\n        nativeURL = nativeURL.substring(0, nativeURL.length - 1);\n    }\n\n    FileEntry.__super__.constructor.apply(this, [true, false, name, fullPath, fileSystem, nativeURL]);\n};\n\nutils.extend(FileEntry, Entry);\n\n/**\n * Creates a new FileWriter associated with the file that this FileEntry represents.\n *\n * @param {Function} successCallback is called with the new FileWriter\n * @param {Function} errorCallback is called with a FileError\n */\nFileEntry.prototype.createWriter = function(successCallback, errorCallback) {\n    this.file(function(filePointer) {\n        var writer = new FileWriter(filePointer);\n\n        if (writer.localURL === null || writer.localURL === \"\") {\n            if (errorCallback) {\n                errorCallback(new FileError(FileError.INVALID_STATE_ERR));\n            }\n        } else {\n            if (successCallback) {\n                successCallback(writer);\n            }\n        }\n    }, errorCallback);\n};\n\n/**\n * Returns a File that represents the current state of the file that this FileEntry represents.\n *\n * @param {Function} successCallback is called with the new File object\n * @param {Function} errorCallback is called with a FileError\n */\nFileEntry.prototype.file = function(successCallback, errorCallback) {\n    var localURL = this.toInternalURL();\n    var win = successCallback && function(f) {\n        var file = new File(f.name, localURL, f.type, f.lastModifiedDate, f.size);\n        successCallback(file);\n    };\n    var fail = errorCallback && function(code) {\n        errorCallback(new FileError(code));\n    };\n    exec(win, fail, \"File\", \"getFileMetadata\", [localURL]);\n};\n\n\nmodule.exports = FileEntry;\n\n},{\"cordova-plugin-file.Entry\":\"cordova-plugin-file.Entry\",\"cordova-plugin-file.File\":\"cordova-plugin-file.File\",\"cordova-plugin-file.FileError\":\"cordova-plugin-file.FileError\",\"cordova-plugin-file.FileWriter\":\"cordova-plugin-file.FileWriter\",\"cordova/exec\":\"cordova/exec\",\"cordova/utils\":\"cordova/utils\"}],\"cordova-plugin-file.FileError\":[function(require,module,exports){\n/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n/**\n * FileError\n */\nfunction FileError(error) {\n  this.code = error || null;\n}\n\n// File error codes\n// Found in DOMException\nFileError.NOT_FOUND_ERR = 1;\nFileError.SECURITY_ERR = 2;\nFileError.ABORT_ERR = 3;\n\n// Added by File API specification\nFileError.NOT_READABLE_ERR = 4;\nFileError.ENCODING_ERR = 5;\nFileError.NO_MODIFICATION_ALLOWED_ERR = 6;\nFileError.INVALID_STATE_ERR = 7;\nFileError.SYNTAX_ERR = 8;\nFileError.INVALID_MODIFICATION_ERR = 9;\nFileError.QUOTA_EXCEEDED_ERR = 10;\nFileError.TYPE_MISMATCH_ERR = 11;\nFileError.PATH_EXISTS_ERR = 12;\n\nmodule.exports = FileError;\n\n},{}],\"cordova-plugin-file.FileReader\":[function(require,module,exports){\n/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\nvar exec = require('cordova/exec'),\n    modulemapper = require('cordova/modulemapper'),\n    utils = require('cordova/utils'),\n    FileError = require('cordova-plugin-file.FileError'),\n    ProgressEvent = require('cordova-plugin-file.ProgressEvent'),\n    origFileReader = modulemapper.getOriginalSymbol(window, 'FileReader');\n\n/**\n * This class reads the mobile device file system.\n *\n * For Android:\n *      The root directory is the root of the file system.\n *      To read from the SD card, the file name is \"sdcard/my_file.txt\"\n * @constructor\n */\nvar FileReader = function() {\n    this._readyState = 0;\n    this._error = null;\n    this._result = null;\n    this._progress = null;\n    this._localURL = '';\n    this._realReader = origFileReader ? new origFileReader() : {};\n};\n\n/**\n * Defines the maximum size to read at a time via the native API. The default value is a compromise between\n * minimizing the overhead of many exec() calls while still reporting progress frequently enough for large files.\n * (Note attempts to allocate more than a few MB of contiguous memory on the native side are likely to cause\n * OOM exceptions, while the JS engine seems to have fewer problems managing large strings or ArrayBuffers.)\n */\nFileReader.READ_CHUNK_SIZE = 256*1024;\n\n// States\nFileReader.EMPTY = 0;\nFileReader.LOADING = 1;\nFileReader.DONE = 2;\n\nutils.defineGetter(FileReader.prototype, 'readyState', function() {\n    return this._localURL ? this._readyState : this._realReader.readyState;\n});\n\nutils.defineGetter(FileReader.prototype, 'error', function() {\n    return this._localURL ? this._error: this._realReader.error;\n});\n\nutils.defineGetter(FileReader.prototype, 'result', function() {\n    return this._localURL ? this._result: this._realReader.result;\n});\n\nfunction defineEvent(eventName) {\n    utils.defineGetterSetter(FileReader.prototype, eventName, function() {\n        return this._realReader[eventName] || null;\n    }, function(value) {\n        this._realReader[eventName] = value;\n    });\n}\ndefineEvent('onloadstart');    // When the read starts.\ndefineEvent('onprogress');     // While reading (and decoding) file or fileBlob data, and reporting partial file data (progress.loaded/progress.total)\ndefineEvent('onload');         // When the read has successfully completed.\ndefineEvent('onerror');        // When the read has failed (see errors).\ndefineEvent('onloadend');      // When the request has completed (either in success or failure).\ndefineEvent('onabort');        // When the read has been aborted. For instance, by invoking the abort() method.\n\nfunction initRead(reader, file) {\n    // Already loading something\n    if (reader.readyState == FileReader.LOADING) {\n      throw new FileError(FileError.INVALID_STATE_ERR);\n    }\n\n    reader._result = null;\n    reader._error = null;\n    reader._progress = 0;\n    reader._readyState = FileReader.LOADING;\n\n    if (typeof file.localURL == 'string') {\n        reader._localURL = file.localURL;\n    } else {\n        reader._localURL = '';\n        return true;\n    }\n\n    if (reader.onloadstart) {\n        reader.onloadstart(new ProgressEvent(\"loadstart\", {target:reader}));\n    }\n}\n\n/**\n * Callback used by the following read* functions to handle incremental or final success.\n * Must be bound to the FileReader's this along with all but the last parameter,\n * e.g. readSuccessCallback.bind(this, \"readAsText\", \"UTF-8\", offset, totalSize, accumulate)\n * @param readType The name of the read function to call.\n * @param encoding Text encoding, or null if this is not a text type read.\n * @param offset Starting offset of the read.\n * @param totalSize Total number of bytes or chars to read.\n * @param accumulate A function that takes the callback result and accumulates it in this._result.\n * @param r Callback result returned by the last read exec() call, or null to begin reading.\n */\nfunction readSuccessCallback(readType, encoding, offset, totalSize, accumulate, r) {\n    if (this._readyState === FileReader.DONE) {\n        return;\n    }\n\n    if (typeof r !== \"undefined\") {\n        accumulate(r);\n        this._progress = Math.min(this._progress + FileReader.READ_CHUNK_SIZE, totalSize);\n\n        if (typeof this.onprogress === \"function\") {\n            this.onprogress(new ProgressEvent(\"progress\", {loaded:this._progress, total:totalSize}));\n        }\n    }\n\n    if (typeof r === \"undefined\" || this._progress < totalSize) {\n        var execArgs = [\n            this._localURL,\n            offset + this._progress,\n            offset + this._progress + Math.min(totalSize - this._progress, FileReader.READ_CHUNK_SIZE)];\n        if (encoding) {\n            execArgs.splice(1, 0, encoding);\n        }\n        exec(\n            readSuccessCallback.bind(this, readType, encoding, offset, totalSize, accumulate),\n            readFailureCallback.bind(this),\n            \"File\", readType, execArgs);\n    } else {\n        this._readyState = FileReader.DONE;\n\n        if (typeof this.onload === \"function\") {\n            this.onload(new ProgressEvent(\"load\", {target:this}));\n        }\n\n        if (typeof this.onloadend === \"function\") {\n            this.onloadend(new ProgressEvent(\"loadend\", {target:this}));\n        }\n    }\n}\n\n/**\n * Callback used by the following read* functions to handle errors.\n * Must be bound to the FileReader's this, e.g. readFailureCallback.bind(this)\n */\nfunction readFailureCallback(e) {\n    if (this._readyState === FileReader.DONE) {\n        return;\n    }\n\n    this._readyState = FileReader.DONE;\n    this._result = null;\n    this._error = new FileError(e);\n\n    if (typeof this.onerror === \"function\") {\n        this.onerror(new ProgressEvent(\"error\", {target:this}));\n    }\n\n    if (typeof this.onloadend === \"function\") {\n        this.onloadend(new ProgressEvent(\"loadend\", {target:this}));\n    }\n}\n\n/**\n * Abort reading file.\n */\nFileReader.prototype.abort = function() {\n    if (origFileReader && !this._localURL) {\n        return this._realReader.abort();\n    }\n    this._result = null;\n\n    if (this._readyState == FileReader.DONE || this._readyState == FileReader.EMPTY) {\n      return;\n    }\n\n    this._readyState = FileReader.DONE;\n\n    // If abort callback\n    if (typeof this.onabort === 'function') {\n        this.onabort(new ProgressEvent('abort', {target:this}));\n    }\n    // If load end callback\n    if (typeof this.onloadend === 'function') {\n        this.onloadend(new ProgressEvent('loadend', {target:this}));\n    }\n};\n\n/**\n * Read text file.\n *\n * @param file          {File} File object containing file properties\n * @param encoding      [Optional] (see http://www.iana.org/assignments/character-sets)\n */\nFileReader.prototype.readAsText = function(file, encoding) {\n    if (initRead(this, file)) {\n        return this._realReader.readAsText(file, encoding);\n    }\n\n    // Default encoding is UTF-8\n    var enc = encoding ? encoding : \"UTF-8\";\n\n    var totalSize = file.end - file.start;\n    readSuccessCallback.bind(this)(\"readAsText\", enc, file.start, totalSize, function(r) {\n        if (this._progress === 0) {\n            this._result = \"\";\n        }\n        this._result += r;\n    }.bind(this));\n};\n\n\n/**\n * Read file and return data as a base64 encoded data url.\n * A data url is of the form:\n *      data:[<mediatype>][;base64],<data>\n *\n * @param file          {File} File object containing file properties\n */\nFileReader.prototype.readAsDataURL = function(file) {\n    if (initRead(this, file)) {\n        return this._realReader.readAsDataURL(file);\n    }\n\n    var totalSize = file.end - file.start;\n    readSuccessCallback.bind(this)(\"readAsDataURL\", null, file.start, totalSize, function(r) {\n        var commaIndex = r.indexOf(',');\n        if (this._progress === 0) {\n            this._result = r;\n        } else {\n            this._result += r.substring(commaIndex + 1);\n        }\n    }.bind(this));\n};\n\n/**\n * Read file and return data as a binary data.\n *\n * @param file          {File} File object containing file properties\n */\nFileReader.prototype.readAsBinaryString = function(file) {\n    if (initRead(this, file)) {\n        return this._realReader.readAsBinaryString(file);\n    }\n\n    var totalSize = file.end - file.start;\n    readSuccessCallback.bind(this)(\"readAsBinaryString\", null, file.start, totalSize, function(r) {\n        if (this._progress === 0) {\n            this._result = \"\";\n        }\n        this._result += r;\n    }.bind(this));\n};\n\n/**\n * Read file and return data as a binary data.\n *\n * @param file          {File} File object containing file properties\n */\nFileReader.prototype.readAsArrayBuffer = function(file) {\n    if (initRead(this, file)) {\n        return this._realReader.readAsArrayBuffer(file);\n    }\n\n    var totalSize = file.end - file.start;\n    readSuccessCallback.bind(this)(\"readAsArrayBuffer\", null, file.start, totalSize, function(r) {\n        var resultArray = (this._progress === 0 ? new Uint8Array(totalSize) : new Uint8Array(this._result));\n        resultArray.set(new Uint8Array(r), this._progress);\n        this._result = resultArray.buffer;\n    }.bind(this));\n};\n\nmodule.exports = FileReader;\n\n},{\"cordova-plugin-file.FileError\":\"cordova-plugin-file.FileError\",\"cordova-plugin-file.ProgressEvent\":\"cordova-plugin-file.ProgressEvent\",\"cordova/exec\":\"cordova/exec\",\"cordova/modulemapper\":\"cordova/modulemapper\",\"cordova/utils\":\"cordova/utils\"}],\"cordova-plugin-file.FileSystem\":[function(require,module,exports){\n/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\nvar DirectoryEntry = require('cordova-plugin-file.DirectoryEntry');\n\n/**\n * An interface representing a file system\n *\n * @constructor\n * {DOMString} name the unique name of the file system (readonly)\n * {DirectoryEntry} root directory of the file system (readonly)\n */\nvar FileSystem = function(name, root) {\n    this.name = name;\n    if (root) {\n        this.root = new DirectoryEntry(root.name, root.fullPath, this, root.nativeURL);\n    } else {\n        this.root = new DirectoryEntry(this.name, '/', this);\n    }\n};\n\nFileSystem.prototype.__format__ = function(fullPath, nativeUrl) {\n    return fullPath;\n};\n\nFileSystem.prototype.toJSON = function() {\n    return \"<FileSystem: \" + this.name + \">\";\n};\n\n// Use instead of encodeURI() when encoding just the path part of a URI rather than an entire URI.\nFileSystem.encodeURIPath = function(path) {\n    // Because # is a valid filename character, it must be encoded to prevent part of the\n    // path from being parsed as a URI fragment.\n    return encodeURI(path).replace(/#/g, '%23');\n};\n\nmodule.exports = FileSystem;\n\n},{\"cordova-plugin-file.DirectoryEntry\":\"cordova-plugin-file.DirectoryEntry\"}],\"cordova-plugin-file.FileUploadOptions\":[function(require,module,exports){\n/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n/**\n * Options to customize the HTTP request used to upload files.\n * @constructor\n * @param fileKey {String}   Name of file request parameter.\n * @param fileName {String}  Filename to be used by the server. Defaults to image.jpg.\n * @param mimeType {String}  Mimetype of the uploaded file. Defaults to image/jpeg.\n * @param params {Object}    Object with key: value params to send to the server.\n * @param headers {Object}   Keys are header names, values are header values. Multiple\n *                           headers of the same name are not supported.\n */\nvar FileUploadOptions = function(fileKey, fileName, mimeType, params, headers, httpMethod) {\n    this.fileKey = fileKey || null;\n    this.fileName = fileName || null;\n    this.mimeType = mimeType || null;\n    this.params = params || null;\n    this.headers = headers || null;\n    this.httpMethod = httpMethod || null;\n};\n\nmodule.exports = FileUploadOptions;\n\n},{}],\"cordova-plugin-file.FileUploadResult\":[function(require,module,exports){\n/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n/**\n * FileUploadResult\n * @constructor\n */\nmodule.exports = function FileUploadResult(size, code, content) {\n\tthis.bytesSent = size;\n\tthis.responseCode = code;\n\tthis.response = content;\n };\n},{}],\"cordova-plugin-file.FileWriter\":[function(require,module,exports){\n/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\nvar exec = require('cordova/exec'),\n    FileError = require('cordova-plugin-file.FileError'),\n    ProgressEvent = require('cordova-plugin-file.ProgressEvent');\n\n/**\n * This class writes to the mobile device file system.\n *\n * For Android:\n *      The root directory is the root of the file system.\n *      To write to the SD card, the file name is \"sdcard/my_file.txt\"\n *\n * @constructor\n * @param file {File} File object containing file properties\n * @param append if true write to the end of the file, otherwise overwrite the file\n */\nvar FileWriter = function(file) {\n    this.fileName = \"\";\n    this.length = 0;\n    if (file) {\n        this.localURL = file.localURL || file;\n        this.length = file.size || 0;\n    }\n    // default is to write at the beginning of the file\n    this.position = 0;\n\n    this.readyState = 0; // EMPTY\n\n    this.result = null;\n\n    // Error\n    this.error = null;\n\n    // Event handlers\n    this.onwritestart = null;   // When writing starts\n    this.onprogress = null;     // While writing the file, and reporting partial file data\n    this.onwrite = null;        // When the write has successfully completed.\n    this.onwriteend = null;     // When the request has completed (either in success or failure).\n    this.onabort = null;        // When the write has been aborted. For instance, by invoking the abort() method.\n    this.onerror = null;        // When the write has failed (see errors).\n};\n\n// States\nFileWriter.INIT = 0;\nFileWriter.WRITING = 1;\nFileWriter.DONE = 2;\n\n/**\n * Abort writing file.\n */\nFileWriter.prototype.abort = function() {\n    // check for invalid state\n    if (this.readyState === FileWriter.DONE || this.readyState === FileWriter.INIT) {\n        throw new FileError(FileError.INVALID_STATE_ERR);\n    }\n\n    // set error\n    this.error = new FileError(FileError.ABORT_ERR);\n\n    this.readyState = FileWriter.DONE;\n\n    // If abort callback\n    if (typeof this.onabort === \"function\") {\n        this.onabort(new ProgressEvent(\"abort\", {\"target\":this}));\n    }\n\n    // If write end callback\n    if (typeof this.onwriteend === \"function\") {\n        this.onwriteend(new ProgressEvent(\"writeend\", {\"target\":this}));\n    }\n};\n\n/**\n * Writes data to the file\n *\n * @param data text or blob to be written\n * @param isPendingBlobReadResult {Boolean} true if the data is the pending blob read operation result\n */\nFileWriter.prototype.write = function(data, isPendingBlobReadResult) {\n\n    var that=this;\n    var supportsBinary = (typeof window.Blob !== 'undefined' && typeof window.ArrayBuffer !== 'undefined');\n    var isProxySupportBlobNatively = (cordova.platformId === \"windows8\" || cordova.platformId === \"windows\");\n    var isBinary;\n\n    // Check to see if the incoming data is a blob\n    if (data instanceof File || (!isProxySupportBlobNatively && supportsBinary && data instanceof Blob)) {\n        var fileReader = new FileReader();\n        fileReader.onload = function() {\n            // Call this method again, with the arraybuffer as argument\n            FileWriter.prototype.write.call(that, this.result, true /* isPendingBlobReadResult */);\n        };\n        fileReader.onerror = function () {\n            // DONE state\n            that.readyState = FileWriter.DONE;\n\n            // Save error\n            that.error = this.error;\n\n            // If onerror callback\n            if (typeof that.onerror === \"function\") {\n                that.onerror(new ProgressEvent(\"error\", {\"target\":that}));\n            }\n\n            // If onwriteend callback\n            if (typeof that.onwriteend === \"function\") {\n                that.onwriteend(new ProgressEvent(\"writeend\", {\"target\":that}));\n            }\n        };\n\n        // WRITING state\n        this.readyState = FileWriter.WRITING;\n\n        if (supportsBinary) {\n            fileReader.readAsArrayBuffer(data);\n        } else {\n            fileReader.readAsText(data);\n        }\n        return;\n    }\n\n    // Mark data type for safer transport over the binary bridge\n    isBinary = supportsBinary && (data instanceof ArrayBuffer);\n    if (isBinary && cordova.platformId === \"windowsphone\") {\n        // create a plain array, using the keys from the Uint8Array view so that we can serialize it\n        data = Array.apply(null, new Uint8Array(data));\n    }\n    \n    // Throw an exception if we are already writing a file\n    if (this.readyState === FileWriter.WRITING && !isPendingBlobReadResult) {\n        throw new FileError(FileError.INVALID_STATE_ERR);\n    }\n\n    // WRITING state\n    this.readyState = FileWriter.WRITING;\n\n    var me = this;\n\n    // If onwritestart callback\n    if (typeof me.onwritestart === \"function\") {\n        me.onwritestart(new ProgressEvent(\"writestart\", {\"target\":me}));\n    }\n\n    // Write file\n    exec(\n        // Success callback\n        function(r) {\n            // If DONE (cancelled), then don't do anything\n            if (me.readyState === FileWriter.DONE) {\n                return;\n            }\n\n            // position always increases by bytes written because file would be extended\n            me.position += r;\n            // The length of the file is now where we are done writing.\n\n            me.length = me.position;\n\n            // DONE state\n            me.readyState = FileWriter.DONE;\n\n            // If onwrite callback\n            if (typeof me.onwrite === \"function\") {\n                me.onwrite(new ProgressEvent(\"write\", {\"target\":me}));\n            }\n\n            // If onwriteend callback\n            if (typeof me.onwriteend === \"function\") {\n                me.onwriteend(new ProgressEvent(\"writeend\", {\"target\":me}));\n            }\n        },\n        // Error callback\n        function(e) {\n            // If DONE (cancelled), then don't do anything\n            if (me.readyState === FileWriter.DONE) {\n                return;\n            }\n\n            // DONE state\n            me.readyState = FileWriter.DONE;\n\n            // Save error\n            me.error = new FileError(e);\n\n            // If onerror callback\n            if (typeof me.onerror === \"function\") {\n                me.onerror(new ProgressEvent(\"error\", {\"target\":me}));\n            }\n\n            // If onwriteend callback\n            if (typeof me.onwriteend === \"function\") {\n                me.onwriteend(new ProgressEvent(\"writeend\", {\"target\":me}));\n            }\n        }, \"File\", \"write\", [this.localURL, data, this.position, isBinary]);\n};\n\n/**\n * Moves the file pointer to the location specified.\n *\n * If the offset is a negative number the position of the file\n * pointer is rewound.  If the offset is greater than the file\n * size the position is set to the end of the file.\n *\n * @param offset is the location to move the file pointer to.\n */\nFileWriter.prototype.seek = function(offset) {\n    // Throw an exception if we are already writing a file\n    if (this.readyState === FileWriter.WRITING) {\n        throw new FileError(FileError.INVALID_STATE_ERR);\n    }\n\n    if (!offset && offset !== 0) {\n        return;\n    }\n\n    // See back from end of file.\n    if (offset < 0) {\n        this.position = Math.max(offset + this.length, 0);\n    }\n    // Offset is bigger than file size so set position\n    // to the end of the file.\n    else if (offset > this.length) {\n        this.position = this.length;\n    }\n    // Offset is between 0 and file size so set the position\n    // to start writing.\n    else {\n        this.position = offset;\n    }\n};\n\n/**\n * Truncates the file to the size specified.\n *\n * @param size to chop the file at.\n */\nFileWriter.prototype.truncate = function(size) {\n    // Throw an exception if we are already writing a file\n    if (this.readyState === FileWriter.WRITING) {\n        throw new FileError(FileError.INVALID_STATE_ERR);\n    }\n\n    // WRITING state\n    this.readyState = FileWriter.WRITING;\n\n    var me = this;\n\n    // If onwritestart callback\n    if (typeof me.onwritestart === \"function\") {\n        me.onwritestart(new ProgressEvent(\"writestart\", {\"target\":this}));\n    }\n\n    // Write file\n    exec(\n        // Success callback\n        function(r) {\n            // If DONE (cancelled), then don't do anything\n            if (me.readyState === FileWriter.DONE) {\n                return;\n            }\n\n            // DONE state\n            me.readyState = FileWriter.DONE;\n\n            // Update the length of the file\n            me.length = r;\n            me.position = Math.min(me.position, r);\n\n            // If onwrite callback\n            if (typeof me.onwrite === \"function\") {\n                me.onwrite(new ProgressEvent(\"write\", {\"target\":me}));\n            }\n\n            // If onwriteend callback\n            if (typeof me.onwriteend === \"function\") {\n                me.onwriteend(new ProgressEvent(\"writeend\", {\"target\":me}));\n            }\n        },\n        // Error callback\n        function(e) {\n            // If DONE (cancelled), then don't do anything\n            if (me.readyState === FileWriter.DONE) {\n                return;\n            }\n\n            // DONE state\n            me.readyState = FileWriter.DONE;\n\n            // Save error\n            me.error = new FileError(e);\n\n            // If onerror callback\n            if (typeof me.onerror === \"function\") {\n                me.onerror(new ProgressEvent(\"error\", {\"target\":me}));\n            }\n\n            // If onwriteend callback\n            if (typeof me.onwriteend === \"function\") {\n                me.onwriteend(new ProgressEvent(\"writeend\", {\"target\":me}));\n            }\n        }, \"File\", \"truncate\", [this.localURL, size]);\n};\n\nmodule.exports = FileWriter;\n\n},{\"cordova-plugin-file.FileError\":\"cordova-plugin-file.FileError\",\"cordova-plugin-file.ProgressEvent\":\"cordova-plugin-file.ProgressEvent\",\"cordova/exec\":\"cordova/exec\"}],\"cordova-plugin-file.File\":[function(require,module,exports){\n/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n/**\n * Constructor.\n * name {DOMString} name of the file, without path information\n * fullPath {DOMString} the full path of the file, including the name\n * type {DOMString} mime type\n * lastModifiedDate {Date} last modified date\n * size {Number} size of the file in bytes\n */\n\nvar File = function(name, localURL, type, lastModifiedDate, size){\n    this.name = name || '';\n    this.localURL = localURL || null;\n    this.type = type || null;\n    this.lastModified = lastModifiedDate || null;\n    // For backwards compatibility, store the timestamp in lastModifiedDate as well\n    this.lastModifiedDate = lastModifiedDate || null;\n    this.size = size || 0;\n\n    // These store the absolute start and end for slicing the file.\n    this.start = 0;\n    this.end = this.size;\n};\n\n/**\n * Returns a \"slice\" of the file. Since Cordova Files don't contain the actual\n * content, this really returns a File with adjusted start and end.\n * Slices of slices are supported.\n * start {Number} The index at which to start the slice (inclusive).\n * end {Number} The index at which to end the slice (exclusive).\n */\nFile.prototype.slice = function(start, end) {\n    var size = this.end - this.start;\n    var newStart = 0;\n    var newEnd = size;\n    if (arguments.length) {\n        if (start < 0) {\n            newStart = Math.max(size + start, 0);\n        } else {\n            newStart = Math.min(size, start);\n        }\n    }\n\n    if (arguments.length >= 2) {\n        if (end < 0) {\n            newEnd = Math.max(size + end, 0);\n        } else {\n            newEnd = Math.min(end, size);\n        }\n    }\n\n    var newFile = new File(this.name, this.localURL, this.type, this.lastModified, this.size);\n    newFile.start = this.start + newStart;\n    newFile.end = this.start + newEnd;\n    return newFile;\n};\n\n\nmodule.exports = File;\n\n},{}],\"cordova-plugin-file.Flags\":[function(require,module,exports){\n/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n/**\n * Supplies arguments to methods that lookup or create files and directories.\n *\n * @param create\n *            {boolean} file or directory if it doesn't exist\n * @param exclusive\n *            {boolean} used with create; if true the command will fail if\n *            target path exists\n */\nfunction Flags(create, exclusive) {\n    this.create = create || false;\n    this.exclusive = exclusive || false;\n}\n\nmodule.exports = Flags;\n\n},{}],\"cordova-plugin-file.LocalFileSystem\":[function(require,module,exports){\n/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\nexports.TEMPORARY = 0;\nexports.PERSISTENT = 1;\n\n},{}],\"cordova-plugin-file.Metadata\":[function(require,module,exports){\n/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n/**\n * Information about the state of the file or directory\n *\n * {Date} modificationTime (readonly)\n */\nvar Metadata = function(metadata) {\n    if (typeof metadata == \"object\") {\n        this.modificationTime = new Date(metadata.modificationTime);\n        this.size = metadata.size || 0;\n    } else if (typeof metadata == \"undefined\") {\n        this.modificationTime = null;\n        this.size = 0;\n    } else {\n        /* Backwards compatiblity with platforms that only return a timestamp */\n        this.modificationTime = new Date(metadata);\n    }\n};\n\nmodule.exports = Metadata;\n\n},{}],\"cordova-plugin-file.ProgressEvent\":[function(require,module,exports){\n/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n// If ProgressEvent exists in global context, use it already, otherwise use our own polyfill\n// Feature test: See if we can instantiate a native ProgressEvent;\n// if so, use that approach,\n// otherwise fill-in with our own implementation.\n//\n// NOTE: right now we always fill in with our own. Down the road would be nice if we can use whatever is native in the webview.\nvar ProgressEvent = (function() {\n    /*\n    var createEvent = function(data) {\n        var event = document.createEvent('Events');\n        event.initEvent('ProgressEvent', false, false);\n        if (data) {\n            for (var i in data) {\n                if (data.hasOwnProperty(i)) {\n                    event[i] = data[i];\n                }\n            }\n            if (data.target) {\n                // TODO: cannot call <some_custom_object>.dispatchEvent\n                // need to first figure out how to implement EventTarget\n            }\n        }\n        return event;\n    };\n    try {\n        var ev = createEvent({type:\"abort\",target:document});\n        return function ProgressEvent(type, data) {\n            data.type = type;\n            return createEvent(data);\n        };\n    } catch(e){\n    */\n        return function ProgressEvent(type, dict) {\n            this.type = type;\n            this.bubbles = false;\n            this.cancelBubble = false;\n            this.cancelable = false;\n            this.lengthComputable = false;\n            this.loaded = dict && dict.loaded ? dict.loaded : 0;\n            this.total = dict && dict.total ? dict.total : 0;\n            this.target = dict && dict.target ? dict.target : null;\n        };\n    //}\n})();\n\nmodule.exports = ProgressEvent;\n\n},{}],\"cordova-plugin-file.androidFileSystem\":[function(require,module,exports){\n/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\nFILESYSTEM_PROTOCOL = \"cdvfile\";\n\nmodule.exports = {\n    __format__: function(fullPath, nativeUrl) {\n        var path;\n        var contentUrlMatch = /^content:\\/\\//.exec(nativeUrl);\n        if (contentUrlMatch) {\n            // When available, use the path from a native content URL, which was already encoded by Android.\n            // This is necessary because JavaScript's encodeURI() does not encode as many characters as\n            // Android, which can result in permission exceptions when the encoding of a content URI\n            // doesn't match the string for which permission was originally granted.\n            path = nativeUrl.substring(contentUrlMatch[0].length - 1);\n        } else {\n            path = FileSystem.encodeURIPath(fullPath);\n            if (!/^\\//.test(path)) {\n                path = '/' + path;\n            }\n            \n            var m = /\\?.*/.exec(nativeUrl);\n            if (m) {\n                path += m[0];\n            }\n        }\n\n        return FILESYSTEM_PROTOCOL + '://localhost/' + this.name + path;\n    }\n};\n\n\n},{}],\"cordova-plugin-file.fileSystemPaths\":[function(require,module,exports){\n/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\nvar exec = require('cordova/exec');\nvar channel = require('cordova/channel');\n\nexports.file = {\n    // Read-only directory where the application is installed.\n    applicationDirectory: null,\n    // Root of app's private writable storage\n    applicationStorageDirectory: null,\n    // Where to put app-specific data files.\n    dataDirectory: null,\n    // Cached files that should survive app restarts.\n    // Apps should not rely on the OS to delete files in here.\n    cacheDirectory: null,\n    // Android: the application space on external storage.\n    externalApplicationStorageDirectory: null,\n    // Android: Where to put app-specific data files on external storage.\n    externalDataDirectory: null,\n    // Android: the application cache on external storage.\n    externalCacheDirectory: null,\n    // Android: the external storage (SD card) root.\n    externalRootDirectory: null,\n    // iOS: Temp directory that the OS can clear at will.\n    tempDirectory: null,\n    // iOS: Holds app-specific files that should be synced (e.g. to iCloud).\n    syncedDataDirectory: null,\n    // iOS: Files private to the app, but that are meaningful to other applications (e.g. Office files)\n    documentsDirectory: null,\n    // BlackBerry10: Files globally available to all apps\n    sharedDirectory: null\n};\n\nchannel.waitForInitialization('onFileSystemPathsReady');\nchannel.onCordovaReady.subscribe(function() {\n    function after(paths) {\n        for (var k in paths) {\n            exports.file[k] = paths[k];\n        }\n        channel.initializationComplete('onFileSystemPathsReady');\n    }\n    exec(after, null, 'File', 'requestAllPaths', []);\n});\n\n\n},{\"cordova/channel\":\"cordova/channel\",\"cordova/exec\":\"cordova/exec\"}],\"cordova-plugin-file.fileSystems-roots\":[function(require,module,exports){\n/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n// Map of fsName -> FileSystem.\nvar fsMap = null;\nvar FileSystem = require('cordova-plugin-file.FileSystem');\nvar exec = require('cordova/exec');\n\n// Overridden by Android, BlackBerry 10 and iOS to populate fsMap.\nrequire('cordova-plugin-file.fileSystems').getFs = function(name, callback) {\n    function success(response) {\n        fsMap = {};\n        for (var i = 0; i < response.length; ++i) {\n            var fsRoot = response[i];\n            var fs = new FileSystem(fsRoot.filesystemName, fsRoot);\n            fsMap[fs.name] = fs;\n        }\n        callback(fsMap[name]);\n    }\n\n    if (fsMap) {\n        callback(fsMap[name]);\n    } else {\n        exec(success, null, \"File\", \"requestAllFileSystems\", []);\n    }\n};\n\n\n},{\"cordova-plugin-file.FileSystem\":\"cordova-plugin-file.FileSystem\",\"cordova-plugin-file.fileSystems\":\"cordova-plugin-file.fileSystems\",\"cordova/exec\":\"cordova/exec\"}],\"cordova-plugin-file.fileSystems\":[function(require,module,exports){\n/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n// Overridden by Android, BlackBerry 10 and iOS to populate fsMap.\nmodule.exports.getFs = function(name, callback) {\n    callback(null);\n};\n\n},{}],\"cordova-plugin-file.isChrome\":[function(require,module,exports){\n/*\r\n *\r\n * Licensed to the Apache Software Foundation (ASF) under one\r\n * or more contributor license agreements.  See the NOTICE file\r\n * distributed with this work for additional information\r\n * regarding copyright ownership.  The ASF licenses this file\r\n * to you under the Apache License, Version 2.0 (the\r\n * \"License\"); you may not use this file except in compliance\r\n * with the License.  You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing,\r\n * software distributed under the License is distributed on an\r\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n * KIND, either express or implied.  See the License for the\r\n * specific language governing permissions and limitations\r\n * under the License.\r\n *\r\n */\r\n\r\nmodule.exports = function () {\r\n    // window.webkitRequestFileSystem and window.webkitResolveLocalFileSystemURL are available only in Chrome and\r\n    // possibly a good flag to indicate that we're running in Chrome\r\n    return window.webkitRequestFileSystem && window.webkitResolveLocalFileSystemURL;\r\n};\r\n\n},{}],\"cordova-plugin-file.requestFileSystem\":[function(require,module,exports){\n/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n(function() {\n    //For browser platform: not all browsers use this file.\n    function checkBrowser() {\n        if (cordova.platformId === \"browser\" && require('cordova-plugin-file.isChrome')()) {\n            module.exports = window.requestFileSystem || window.webkitRequestFileSystem;\n            return true;\n        }\n        return false;\n    }\n    if (checkBrowser()) {\n        return;\n    }\n\n    var argscheck = require('cordova/argscheck'),\n        FileError = require('cordova-plugin-file.FileError'),\n        FileSystem = require('cordova-plugin-file.FileSystem'),\n        exec = require('cordova/exec');\n    var fileSystems = require('cordova-plugin-file.fileSystems');\n\n    /**\n     * Request a file system in which to store application data.\n     * @param type  local file system type\n     * @param size  indicates how much storage space, in bytes, the application expects to need\n     * @param successCallback  invoked with a FileSystem object\n     * @param errorCallback  invoked if error occurs retrieving file system\n     */\n    var requestFileSystem = function(type, size, successCallback, errorCallback) {\n        argscheck.checkArgs('nnFF', 'requestFileSystem', arguments);\n        var fail = function(code) {\n            if (errorCallback) {\n                errorCallback(new FileError(code));\n            }\n        };\n\n        if (type < 0) {\n            fail(FileError.SYNTAX_ERR);\n        } else {\n            // if successful, return a FileSystem object\n            var success = function(file_system) {\n                if (file_system) {\n                    if (successCallback) {\n                        fileSystems.getFs(file_system.name, function(fs) {\n                            // This should happen only on platforms that haven't implemented requestAllFileSystems (windows)\n                            if (!fs) {\n                                fs = new FileSystem(file_system.name, file_system.root);\n                            }\n                            successCallback(fs);\n                        });\n                    }\n                }\n                else {\n                    // no FileSystem object returned\n                    fail(FileError.NOT_FOUND_ERR);\n                }\n            };\n            exec(success, fail, \"File\", \"requestFileSystem\", [type, size]);\n        }\n    };\n\n    module.exports = requestFileSystem;\n})();\n\n},{\"cordova-plugin-file.FileError\":\"cordova-plugin-file.FileError\",\"cordova-plugin-file.FileSystem\":\"cordova-plugin-file.FileSystem\",\"cordova-plugin-file.fileSystems\":\"cordova-plugin-file.fileSystems\",\"cordova-plugin-file.isChrome\":\"cordova-plugin-file.isChrome\",\"cordova/argscheck\":\"cordova/argscheck\",\"cordova/exec\":\"cordova/exec\"}],\"cordova-plugin-file.resolveLocalFileSystemURI\":[function(require,module,exports){\n/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n(function() {\n    //For browser platform: not all browsers use overrided `resolveLocalFileSystemURL`.\n    function checkBrowser() {\n        if (cordova.platformId === \"browser\" && require('cordova-plugin-file.isChrome')()) {\n            module.exports.resolveLocalFileSystemURL = window.resolveLocalFileSystemURL || window.webkitResolveLocalFileSystemURL;\n            return true;\n        }\n        return false;\n    }\n    if (checkBrowser()) {\n        return;\n    }\n\n    var argscheck = require('cordova/argscheck'),\n        DirectoryEntry = require('cordova-plugin-file.DirectoryEntry'),\n        FileEntry = require('cordova-plugin-file.FileEntry'),\n        FileError = require('cordova-plugin-file.FileError'),\n        exec = require('cordova/exec');\n    var fileSystems = require('cordova-plugin-file.fileSystems');\n\n    /**\n     * Look up file system Entry referred to by local URI.\n     * @param {DOMString} uri  URI referring to a local file or directory\n     * @param successCallback  invoked with Entry object corresponding to URI\n     * @param errorCallback    invoked if error occurs retrieving file system entry\n     */\n    module.exports.resolveLocalFileSystemURL = module.exports.resolveLocalFileSystemURL || function(uri, successCallback, errorCallback) {\n        argscheck.checkArgs('sFF', 'resolveLocalFileSystemURI', arguments);\n        // error callback\n        var fail = function(error) {\n            if (errorCallback) {\n                errorCallback(new FileError(error));\n            }\n        };\n        // sanity check for 'not:valid:filename' or '/not:valid:filename'\n        // file.spec.12 window.resolveLocalFileSystemURI should error (ENCODING_ERR) when resolving invalid URI with leading /.\n        if(!uri || uri.split(\":\").length > 2) {\n            setTimeout( function() {\n                fail(FileError.ENCODING_ERR);\n            },0);\n            return;\n        }\n        // if successful, return either a file or directory entry\n        var success = function(entry) {\n            if (entry) {\n                if (successCallback) {\n                    // create appropriate Entry object\n                    var fsName = entry.filesystemName || (entry.filesystem && entry.filesystem.name) || (entry.filesystem == window.PERSISTENT ? 'persistent' : 'temporary');\n                    fileSystems.getFs(fsName, function(fs) {\n                        // This should happen only on platforms that haven't implemented requestAllFileSystems (windows)\n                        if (!fs) {\n                            fs = new FileSystem(fsName, {name:\"\", fullPath:\"/\"});\n                        }\n                        var result = (entry.isDirectory) ? new DirectoryEntry(entry.name, entry.fullPath, fs, entry.nativeURL) : new FileEntry(entry.name, entry.fullPath, fs, entry.nativeURL);\n                        successCallback(result);\n                    });\n                }\n            }\n            else {\n                // no Entry object returned\n                fail(FileError.NOT_FOUND_ERR);\n            }\n        };\n\n        exec(success, fail, \"File\", \"resolveLocalFileSystemURI\", [uri]);\n    };\n\n    module.exports.resolveLocalFileSystemURI = function() {\n        console.log(\"resolveLocalFileSystemURI is deprecated. Please call resolveLocalFileSystemURL instead.\");\n        module.exports.resolveLocalFileSystemURL.apply(this, arguments);\n    };\n})();\n\n},{\"cordova-plugin-file.DirectoryEntry\":\"cordova-plugin-file.DirectoryEntry\",\"cordova-plugin-file.FileEntry\":\"cordova-plugin-file.FileEntry\",\"cordova-plugin-file.FileError\":\"cordova-plugin-file.FileError\",\"cordova-plugin-file.fileSystems\":\"cordova-plugin-file.fileSystems\",\"cordova-plugin-file.isChrome\":\"cordova-plugin-file.isChrome\",\"cordova/argscheck\":\"cordova/argscheck\",\"cordova/exec\":\"cordova/exec\"}],\"cordova-plugin-inappbrowser.inappbrowser\":[function(require,module,exports){\n/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n(function() {\n    // special patch to correctly work on Ripple emulator (CB-9760)\n    if (window.parent && !!window.parent.ripple) { // https://gist.github.com/triceam/4658021\n        module.exports = window.open.bind(window); // fallback to default window.open behaviour\n        return;\n    }\n\n    var exec = require('cordova/exec');\n    var channel = require('cordova/channel');\n    var modulemapper = require('cordova/modulemapper');\n    var urlutil = require('cordova/urlutil');\n\n    function InAppBrowser() {\n       this.channels = {\n            'loadstart': channel.create('loadstart'),\n            'loadstop' : channel.create('loadstop'),\n            'loaderror' : channel.create('loaderror'),\n            'exit' : channel.create('exit')\n       };\n    }\n\n    InAppBrowser.prototype = {\n        _eventHandler: function (event) {\n            if (event && (event.type in this.channels)) {\n                this.channels[event.type].fire(event);\n            }\n        },\n        close: function (eventname) {\n            exec(null, null, \"InAppBrowser\", \"close\", []);\n        },\n        show: function (eventname) {\n          exec(null, null, \"InAppBrowser\", \"show\", []);\n        },\n        addEventListener: function (eventname,f) {\n            if (eventname in this.channels) {\n                this.channels[eventname].subscribe(f);\n            }\n        },\n        removeEventListener: function(eventname, f) {\n            if (eventname in this.channels) {\n                this.channels[eventname].unsubscribe(f);\n            }\n        },\n\n        executeScript: function(injectDetails, cb) {\n            if (injectDetails.code) {\n                exec(cb, null, \"InAppBrowser\", \"injectScriptCode\", [injectDetails.code, !!cb]);\n            } else if (injectDetails.file) {\n                exec(cb, null, \"InAppBrowser\", \"injectScriptFile\", [injectDetails.file, !!cb]);\n            } else {\n                throw new Error('executeScript requires exactly one of code or file to be specified');\n            }\n        },\n\n        insertCSS: function(injectDetails, cb) {\n            if (injectDetails.code) {\n                exec(cb, null, \"InAppBrowser\", \"injectStyleCode\", [injectDetails.code, !!cb]);\n            } else if (injectDetails.file) {\n                exec(cb, null, \"InAppBrowser\", \"injectStyleFile\", [injectDetails.file, !!cb]);\n            } else {\n                throw new Error('insertCSS requires exactly one of code or file to be specified');\n            }\n        }\n    };\n\n    module.exports = function(strUrl, strWindowName, strWindowFeatures, callbacks) {\n        // Don't catch calls that write to existing frames (e.g. named iframes).\n        if (window.frames && window.frames[strWindowName]) {\n            var origOpenFunc = modulemapper.getOriginalSymbol(window, 'open');\n            return origOpenFunc.apply(window, arguments);\n        }\n\n        strUrl = urlutil.makeAbsolute(strUrl);\n        var iab = new InAppBrowser();\n\n        callbacks = callbacks || {};\n        for (var callbackName in callbacks) {\n            iab.addEventListener(callbackName, callbacks[callbackName]);\n        }\n\n        var cb = function(eventname) {\n           iab._eventHandler(eventname);\n        };\n\n        strWindowFeatures = strWindowFeatures || \"\";\n\n        exec(cb, cb, \"InAppBrowser\", \"open\", [strUrl, strWindowName, strWindowFeatures]);\n        return iab;\n    };\n})();\n\n},{\"cordova/channel\":\"cordova/channel\",\"cordova/exec\":\"cordova/exec\",\"cordova/modulemapper\":\"cordova/modulemapper\",\"cordova/urlutil\":\"cordova/urlutil\"}],\"cordova-plugin-network-information.Connection\":[function(require,module,exports){\n/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n/**\n * Network status\n */\nmodule.exports = {\n        UNKNOWN: \"unknown\",\n        ETHERNET: \"ethernet\",\n        WIFI: \"wifi\",\n        CELL_2G: \"2g\",\n        CELL_3G: \"3g\",\n        CELL_4G: \"4g\",\n        CELL:\"cellular\",\n        NONE: \"none\"\n};\n\n},{}],\"cordova-plugin-network-information.network\":[function(require,module,exports){\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\nvar exec = require('cordova/exec'),\n    cordova = require('cordova'),\n    channel = require('cordova/channel'),\n    utils = require('cordova/utils');\n\n// Link the onLine property with the Cordova-supplied network info.\n// This works because we clobber the navigator object with our own\n// object in bootstrap.js.\n// Browser platform do not need to define this property, because\n// it is already supported by modern browsers\nif (cordova.platformId !== 'browser' && typeof navigator != 'undefined') {\n    utils.defineGetter(navigator, 'onLine', function() {\n        return this.connection.type != 'none';\n    });\n}\n\nfunction NetworkConnection() {\n    this.type = 'unknown';\n}\n\n/**\n * Get connection info\n *\n * @param {Function} successCallback The function to call when the Connection data is available\n * @param {Function} errorCallback The function to call when there is an error getting the Connection data. (OPTIONAL)\n */\nNetworkConnection.prototype.getInfo = function(successCallback, errorCallback) {\n    exec(successCallback, errorCallback, \"NetworkStatus\", \"getConnectionInfo\", []);\n};\n\nvar me = new NetworkConnection();\nvar timerId = null;\nvar timeout = 500;\n\nchannel.createSticky('onCordovaConnectionReady');\nchannel.waitForInitialization('onCordovaConnectionReady');\n\nchannel.onCordovaReady.subscribe(function() {\n    me.getInfo(function(info) {\n        me.type = info;\n        if (info === \"none\") {\n            // set a timer if still offline at the end of timer send the offline event\n            timerId = setTimeout(function(){\n                cordova.fireDocumentEvent(\"offline\");\n                timerId = null;\n            }, timeout);\n        } else {\n            // If there is a current offline event pending clear it\n            if (timerId !== null) {\n                clearTimeout(timerId);\n                timerId = null;\n            }\n            cordova.fireDocumentEvent(\"online\");\n        }\n\n        // should only fire this once\n        if (channel.onCordovaConnectionReady.state !== 2) {\n            channel.onCordovaConnectionReady.fire();\n        }\n    },\n    function (e) {\n        // If we can't get the network info we should still tell Cordova\n        // to fire the deviceready event.\n        if (channel.onCordovaConnectionReady.state !== 2) {\n            channel.onCordovaConnectionReady.fire();\n        }\n        console.log(\"Error initializing Network Connection: \" + e);\n    });\n});\n\nmodule.exports = me;\n\n},{\"cordova\":\"cordova\",\"cordova/channel\":\"cordova/channel\",\"cordova/exec\":\"cordova/exec\",\"cordova/utils\":\"cordova/utils\"}],\"cordova/android/nativeapiprovider\":[function(require,module,exports){\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n*/\n\n/**\n * Exports the ExposedJsApi.java object if available, otherwise exports the PromptBasedNativeApi.\n */\n\nvar nativeApi = this._cordovaNative || require('cordova/android/promptbasednativeapi');\nvar currentApi = nativeApi;\n\nmodule.exports = {\n    get: function() { return currentApi; },\n    setPreferPrompt: function(value) {\n        currentApi = value ? require('cordova/android/promptbasednativeapi') : nativeApi;\n    },\n    // Used only by tests.\n    set: function(value) {\n        currentApi = value;\n    }\n};\n\n},{\"cordova/android/promptbasednativeapi\":\"cordova/android/promptbasednativeapi\"}],\"cordova/android/promptbasednativeapi\":[function(require,module,exports){\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n*/\n\n/**\n * Implements the API of ExposedJsApi.java, but uses prompt() to communicate.\n * This is used pre-JellyBean, where addJavascriptInterface() is disabled.\n */\n\nmodule.exports = {\n    exec: function(bridgeSecret, service, action, callbackId, argsJson) {\n        return prompt(argsJson, 'gap:'+JSON.stringify([bridgeSecret, service, action, callbackId]));\n    },\n    setNativeToJsBridgeMode: function(bridgeSecret, value) {\n        prompt(value, 'gap_bridge_mode:' + bridgeSecret);\n    },\n    retrieveJsMessages: function(bridgeSecret, fromOnlineEvent) {\n        return prompt(+fromOnlineEvent, 'gap_poll:' + bridgeSecret);\n    }\n};\n\n},{}],\"cordova/argscheck\":[function(require,module,exports){\n/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\nvar utils = require('cordova/utils');\n\nvar moduleExports = module.exports;\n\nvar typeMap = {\n    'A': 'Array',\n    'D': 'Date',\n    'N': 'Number',\n    'S': 'String',\n    'F': 'Function',\n    'O': 'Object'\n};\n\nfunction extractParamName(callee, argIndex) {\n    return (/.*?\\((.*?)\\)/).exec(callee)[1].split(', ')[argIndex];\n}\n\nfunction checkArgs(spec, functionName, args, opt_callee) {\n    if (!moduleExports.enableChecks) {\n        return;\n    }\n    var errMsg = null;\n    var typeName;\n    for (var i = 0; i < spec.length; ++i) {\n        var c = spec.charAt(i),\n            cUpper = c.toUpperCase(),\n            arg = args[i];\n        // Asterix means allow anything.\n        if (c == '*') {\n            continue;\n        }\n        typeName = utils.typeName(arg);\n        if ((arg === null || arg === undefined) && c == cUpper) {\n            continue;\n        }\n        if (typeName != typeMap[cUpper]) {\n            errMsg = 'Expected ' + typeMap[cUpper];\n            break;\n        }\n    }\n    if (errMsg) {\n        errMsg += ', but got ' + typeName + '.';\n        errMsg = 'Wrong type for parameter \"' + extractParamName(opt_callee || args.callee, i) + '\" of ' + functionName + ': ' + errMsg;\n        // Don't log when running unit tests.\n        if (typeof jasmine == 'undefined') {\n            console.error(errMsg);\n        }\n        throw TypeError(errMsg);\n    }\n}\n\nfunction getValue(value, defaultValue) {\n    return value === undefined ? defaultValue : value;\n}\n\nmoduleExports.checkArgs = checkArgs;\nmoduleExports.getValue = getValue;\nmoduleExports.enableChecks = true;\n\n\n},{\"cordova/utils\":\"cordova/utils\"}],\"cordova/base64\":[function(require,module,exports){\n/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\nvar base64 = exports;\n\nbase64.fromArrayBuffer = function(arrayBuffer) {\n    var array = new Uint8Array(arrayBuffer);\n    return uint8ToBase64(array);\n};\n\nbase64.toArrayBuffer = function(str) {\n    var decodedStr = typeof atob != 'undefined' ? atob(str) : new Buffer(str,'base64').toString('binary');\n    var arrayBuffer = new ArrayBuffer(decodedStr.length);\n    var array = new Uint8Array(arrayBuffer);\n    for (var i=0, len=decodedStr.length; i < len; i++) {\n        array[i] = decodedStr.charCodeAt(i);\n    }\n    return arrayBuffer;\n};\n\n//------------------------------------------------------------------------------\n\n/* This code is based on the performance tests at http://jsperf.com/b64tests\n * This 12-bit-at-a-time algorithm was the best performing version on all\n * platforms tested.\n */\n\nvar b64_6bit = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nvar b64_12bit;\n\nvar b64_12bitTable = function() {\n    b64_12bit = [];\n    for (var i=0; i<64; i++) {\n        for (var j=0; j<64; j++) {\n            b64_12bit[i*64+j] = b64_6bit[i] + b64_6bit[j];\n        }\n    }\n    b64_12bitTable = function() { return b64_12bit; };\n    return b64_12bit;\n};\n\nfunction uint8ToBase64(rawData) {\n    var numBytes = rawData.byteLength;\n    var output=\"\";\n    var segment;\n    var table = b64_12bitTable();\n    for (var i=0;i<numBytes-2;i+=3) {\n        segment = (rawData[i] << 16) + (rawData[i+1] << 8) + rawData[i+2];\n        output += table[segment >> 12];\n        output += table[segment & 0xfff];\n    }\n    if (numBytes - i == 2) {\n        segment = (rawData[i] << 16) + (rawData[i+1] << 8);\n        output += table[segment >> 12];\n        output += b64_6bit[(segment & 0xfff) >> 6];\n        output += '=';\n    } else if (numBytes - i == 1) {\n        segment = (rawData[i] << 16);\n        output += table[segment >> 12];\n        output += '==';\n    }\n    return output;\n}\n\n},{}],\"cordova/builder\":[function(require,module,exports){\n/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\nvar utils = require('cordova/utils');\n\nfunction each(objects, func, context) {\n    for (var prop in objects) {\n        if (objects.hasOwnProperty(prop)) {\n            func.apply(context, [objects[prop], prop]);\n        }\n    }\n}\n\nfunction clobber(obj, key, value) {\n    exports.replaceHookForTesting(obj, key);\n    var needsProperty = false;\n    try {\n        obj[key] = value;\n    } catch (e) {\n        needsProperty = true;\n    }\n    // Getters can only be overridden by getters.\n    if (needsProperty || obj[key] !== value) {\n        utils.defineGetter(obj, key, function() {\n            return value;\n        });\n    }\n}\n\nfunction assignOrWrapInDeprecateGetter(obj, key, value, message) {\n    if (message) {\n        utils.defineGetter(obj, key, function() {\n            console.log(message);\n            delete obj[key];\n            clobber(obj, key, value);\n            return value;\n        });\n    } else {\n        clobber(obj, key, value);\n    }\n}\n\nfunction include(parent, objects, clobber, merge) {\n    each(objects, function (obj, key) {\n        try {\n            var result = obj.path ? require(obj.path) : {};\n\n            if (clobber) {\n                // Clobber if it doesn't exist.\n                if (typeof parent[key] === 'undefined') {\n                    assignOrWrapInDeprecateGetter(parent, key, result, obj.deprecated);\n                } else if (typeof obj.path !== 'undefined') {\n                    // If merging, merge properties onto parent, otherwise, clobber.\n                    if (merge) {\n                        recursiveMerge(parent[key], result);\n                    } else {\n                        assignOrWrapInDeprecateGetter(parent, key, result, obj.deprecated);\n                    }\n                }\n                result = parent[key];\n            } else {\n                // Overwrite if not currently defined.\n                if (typeof parent[key] == 'undefined') {\n                    assignOrWrapInDeprecateGetter(parent, key, result, obj.deprecated);\n                } else {\n                    // Set result to what already exists, so we can build children into it if they exist.\n                    result = parent[key];\n                }\n            }\n\n            if (obj.children) {\n                include(result, obj.children, clobber, merge);\n            }\n        } catch(e) {\n            utils.alert('Exception building Cordova JS globals: ' + e + ' for key \"' + key + '\"');\n        }\n    });\n}\n\n/**\n * Merge properties from one object onto another recursively.  Properties from\n * the src object will overwrite existing target property.\n *\n * @param target Object to merge properties into.\n * @param src Object to merge properties from.\n */\nfunction recursiveMerge(target, src) {\n    for (var prop in src) {\n        if (src.hasOwnProperty(prop)) {\n            if (target.prototype && target.prototype.constructor === target) {\n                // If the target object is a constructor override off prototype.\n                clobber(target.prototype, prop, src[prop]);\n            } else {\n                if (typeof src[prop] === 'object' && typeof target[prop] === 'object') {\n                    recursiveMerge(target[prop], src[prop]);\n                } else {\n                    clobber(target, prop, src[prop]);\n                }\n            }\n        }\n    }\n}\n\nexports.buildIntoButDoNotClobber = function(objects, target) {\n    include(target, objects, false, false);\n};\nexports.buildIntoAndClobber = function(objects, target) {\n    include(target, objects, true, false);\n};\nexports.buildIntoAndMerge = function(objects, target) {\n    include(target, objects, true, true);\n};\nexports.recursiveMerge = recursiveMerge;\nexports.assignOrWrapInDeprecateGetter = assignOrWrapInDeprecateGetter;\nexports.replaceHookForTesting = function() {};\n\n},{\"cordova/utils\":\"cordova/utils\"}],\"cordova/channel\":[function(require,module,exports){\n/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\nvar utils = require('cordova/utils'),\n    nextGuid = 1;\n\n/**\n * Custom pub-sub \"channel\" that can have functions subscribed to it\n * This object is used to define and control firing of events for\n * cordova initialization, as well as for custom events thereafter.\n *\n * The order of events during page load and Cordova startup is as follows:\n *\n * onDOMContentLoaded*         Internal event that is received when the web page is loaded and parsed.\n * onNativeReady*              Internal event that indicates the Cordova native side is ready.\n * onCordovaReady*             Internal event fired when all Cordova JavaScript objects have been created.\n * onDeviceReady*              User event fired to indicate that Cordova is ready\n * onResume                    User event fired to indicate a start/resume lifecycle event\n * onPause                     User event fired to indicate a pause lifecycle event\n *\n * The events marked with an * are sticky. Once they have fired, they will stay in the fired state.\n * All listeners that subscribe after the event is fired will be executed right away.\n *\n * The only Cordova events that user code should register for are:\n *      deviceready           Cordova native code is initialized and Cordova APIs can be called from JavaScript\n *      pause                 App has moved to background\n *      resume                App has returned to foreground\n *\n * Listeners can be registered as:\n *      document.addEventListener(\"deviceready\", myDeviceReadyListener, false);\n *      document.addEventListener(\"resume\", myResumeListener, false);\n *      document.addEventListener(\"pause\", myPauseListener, false);\n *\n * The DOM lifecycle events should be used for saving and restoring state\n *      window.onload\n *      window.onunload\n *\n */\n\n/**\n * Channel\n * @constructor\n * @param type  String the channel name\n */\nvar Channel = function(type, sticky) {\n    this.type = type;\n    // Map of guid -> function.\n    this.handlers = {};\n    // 0 = Non-sticky, 1 = Sticky non-fired, 2 = Sticky fired.\n    this.state = sticky ? 1 : 0;\n    // Used in sticky mode to remember args passed to fire().\n    this.fireArgs = null;\n    // Used by onHasSubscribersChange to know if there are any listeners.\n    this.numHandlers = 0;\n    // Function that is called when the first listener is subscribed, or when\n    // the last listener is unsubscribed.\n    this.onHasSubscribersChange = null;\n},\n    channel = {\n        /**\n         * Calls the provided function only after all of the channels specified\n         * have been fired. All channels must be sticky channels.\n         */\n        join: function(h, c) {\n            var len = c.length,\n                i = len,\n                f = function() {\n                    if (!(--i)) h();\n                };\n            for (var j=0; j<len; j++) {\n                if (c[j].state === 0) {\n                    throw Error('Can only use join with sticky channels.');\n                }\n                c[j].subscribe(f);\n            }\n            if (!len) h();\n        },\n        create: function(type) {\n            return channel[type] = new Channel(type, false);\n        },\n        createSticky: function(type) {\n            return channel[type] = new Channel(type, true);\n        },\n\n        /**\n         * cordova Channels that must fire before \"deviceready\" is fired.\n         */\n        deviceReadyChannelsArray: [],\n        deviceReadyChannelsMap: {},\n\n        /**\n         * Indicate that a feature needs to be initialized before it is ready to be used.\n         * This holds up Cordova's \"deviceready\" event until the feature has been initialized\n         * and Cordova.initComplete(feature) is called.\n         *\n         * @param feature {String}     The unique feature name\n         */\n        waitForInitialization: function(feature) {\n            if (feature) {\n                var c = channel[feature] || this.createSticky(feature);\n                this.deviceReadyChannelsMap[feature] = c;\n                this.deviceReadyChannelsArray.push(c);\n            }\n        },\n\n        /**\n         * Indicate that initialization code has completed and the feature is ready to be used.\n         *\n         * @param feature {String}     The unique feature name\n         */\n        initializationComplete: function(feature) {\n            var c = this.deviceReadyChannelsMap[feature];\n            if (c) {\n                c.fire();\n            }\n        }\n    };\n\nfunction forceFunction(f) {\n    if (typeof f != 'function') throw \"Function required as first argument!\";\n}\n\n/**\n * Subscribes the given function to the channel. Any time that\n * Channel.fire is called so too will the function.\n * Optionally specify an execution context for the function\n * and a guid that can be used to stop subscribing to the channel.\n * Returns the guid.\n */\nChannel.prototype.subscribe = function(f, c) {\n    // need a function to call\n    forceFunction(f);\n    if (this.state == 2) {\n        f.apply(c || this, this.fireArgs);\n        return;\n    }\n\n    var func = f,\n        guid = f.observer_guid;\n    if (typeof c == \"object\") { func = utils.close(c, f); }\n\n    if (!guid) {\n        // first time any channel has seen this subscriber\n        guid = '' + nextGuid++;\n    }\n    func.observer_guid = guid;\n    f.observer_guid = guid;\n\n    // Don't add the same handler more than once.\n    if (!this.handlers[guid]) {\n        this.handlers[guid] = func;\n        this.numHandlers++;\n        if (this.numHandlers == 1) {\n            this.onHasSubscribersChange && this.onHasSubscribersChange();\n        }\n    }\n};\n\n/**\n * Unsubscribes the function with the given guid from the channel.\n */\nChannel.prototype.unsubscribe = function(f) {\n    // need a function to unsubscribe\n    forceFunction(f);\n\n    var guid = f.observer_guid,\n        handler = this.handlers[guid];\n    if (handler) {\n        delete this.handlers[guid];\n        this.numHandlers--;\n        if (this.numHandlers === 0) {\n            this.onHasSubscribersChange && this.onHasSubscribersChange();\n        }\n    }\n};\n\n/**\n * Calls all functions subscribed to this channel.\n */\nChannel.prototype.fire = function(e) {\n    var fail = false,\n        fireArgs = Array.prototype.slice.call(arguments);\n    // Apply stickiness.\n    if (this.state == 1) {\n        this.state = 2;\n        this.fireArgs = fireArgs;\n    }\n    if (this.numHandlers) {\n        // Copy the values first so that it is safe to modify it from within\n        // callbacks.\n        var toCall = [];\n        for (var item in this.handlers) {\n            toCall.push(this.handlers[item]);\n        }\n        for (var i = 0; i < toCall.length; ++i) {\n            toCall[i].apply(this, fireArgs);\n        }\n        if (this.state == 2 && this.numHandlers) {\n            this.numHandlers = 0;\n            this.handlers = {};\n            this.onHasSubscribersChange && this.onHasSubscribersChange();\n        }\n    }\n};\n\n\n// defining them here so they are ready super fast!\n// DOM event that is received when the web page is loaded and parsed.\nchannel.createSticky('onDOMContentLoaded');\n\n// Event to indicate the Cordova native side is ready.\nchannel.createSticky('onNativeReady');\n\n// Event to indicate that all Cordova JavaScript objects have been created\n// and it's time to run plugin constructors.\nchannel.createSticky('onCordovaReady');\n\n// Event to indicate that all automatically loaded JS plugins are loaded and ready.\n// FIXME remove this\nchannel.createSticky('onPluginsReady');\n\n// Event to indicate that Cordova is ready\nchannel.createSticky('onDeviceReady');\n\n// Event to indicate a resume lifecycle event\nchannel.create('onResume');\n\n// Event to indicate a pause lifecycle event\nchannel.create('onPause');\n\n// Channels that must fire before \"deviceready\" is fired.\nchannel.waitForInitialization('onCordovaReady');\nchannel.waitForInitialization('onDOMContentLoaded');\n\nmodule.exports = channel;\n\n},{\"cordova/utils\":\"cordova/utils\"}],\"cordova/exec/proxy\":[function(require,module,exports){\n/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n\n// internal map of proxy function\nvar CommandProxyMap = {};\n\nmodule.exports = {\n\n    // example: cordova.commandProxy.add(\"Accelerometer\",{getCurrentAcceleration: function(successCallback, errorCallback, options) {...},...);\n    add:function(id,proxyObj) {\n        console.log(\"adding proxy for \" + id);\n        CommandProxyMap[id] = proxyObj;\n        return proxyObj;\n    },\n\n    // cordova.commandProxy.remove(\"Accelerometer\");\n    remove:function(id) {\n        var proxy = CommandProxyMap[id];\n        delete CommandProxyMap[id];\n        CommandProxyMap[id] = null;\n        return proxy;\n    },\n\n    get:function(service,action) {\n        return ( CommandProxyMap[service] ? CommandProxyMap[service][action] : null );\n    }\n};\n},{}],\"cordova/exec\":[function(require,module,exports){\n/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n/**\n * Execute a cordova command.  It is up to the native side whether this action\n * is synchronous or asynchronous.  The native side can return:\n *      Synchronous: PluginResult object as a JSON string\n *      Asynchronous: Empty string \"\"\n * If async, the native side will cordova.callbackSuccess or cordova.callbackError,\n * depending upon the result of the action.\n *\n * @param {Function} success    The success callback\n * @param {Function} fail       The fail callback\n * @param {String} service      The name of the service to use\n * @param {String} action       Action to be run in cordova\n * @param {String[]} [args]     Zero or more arguments to pass to the method\n */\nvar cordova = require('cordova'),\n    nativeApiProvider = require('cordova/android/nativeapiprovider'),\n    utils = require('cordova/utils'),\n    base64 = require('cordova/base64'),\n    channel = require('cordova/channel'),\n    jsToNativeModes = {\n        PROMPT: 0,\n        JS_OBJECT: 1\n    },\n    nativeToJsModes = {\n        // Polls for messages using the JS->Native bridge.\n        POLLING: 0,\n        // For LOAD_URL to be viable, it would need to have a work-around for\n        // the bug where the soft-keyboard gets dismissed when a message is sent.\n        LOAD_URL: 1,\n        // For the ONLINE_EVENT to be viable, it would need to intercept all event\n        // listeners (both through addEventListener and window.ononline) as well\n        // as set the navigator property itself.\n        ONLINE_EVENT: 2\n    },\n    jsToNativeBridgeMode,  // Set lazily.\n    nativeToJsBridgeMode = nativeToJsModes.ONLINE_EVENT,\n    pollEnabled = false,\n    bridgeSecret = -1;\n\nvar messagesFromNative = [];\nvar isProcessing = false;\nvar resolvedPromise = typeof Promise == 'undefined' ? null : Promise.resolve();\nvar nextTick = resolvedPromise ? function(fn) { resolvedPromise.then(fn); } : function(fn) { setTimeout(fn); };\n\nfunction androidExec(success, fail, service, action, args) {\n    if (bridgeSecret < 0) {\n        // If we ever catch this firing, we'll need to queue up exec()s\n        // and fire them once we get a secret. For now, I don't think\n        // it's possible for exec() to be called since plugins are parsed but\n        // not run until until after onNativeReady.\n        throw new Error('exec() called without bridgeSecret');\n    }\n    // Set default bridge modes if they have not already been set.\n    // By default, we use the failsafe, since addJavascriptInterface breaks too often\n    if (jsToNativeBridgeMode === undefined) {\n        androidExec.setJsToNativeBridgeMode(jsToNativeModes.JS_OBJECT);\n    }\n\n    // Process any ArrayBuffers in the args into a string.\n    for (var i = 0; i < args.length; i++) {\n        if (utils.typeName(args[i]) == 'ArrayBuffer') {\n            args[i] = base64.fromArrayBuffer(args[i]);\n        }\n    }\n\n    var callbackId = service + cordova.callbackId++,\n        argsJson = JSON.stringify(args);\n\n    if (success || fail) {\n        cordova.callbacks[callbackId] = {success:success, fail:fail};\n    }\n\n    var msgs = nativeApiProvider.get().exec(bridgeSecret, service, action, callbackId, argsJson);\n    // If argsJson was received by Java as null, try again with the PROMPT bridge mode.\n    // This happens in rare circumstances, such as when certain Unicode characters are passed over the bridge on a Galaxy S2.  See CB-2666.\n    if (jsToNativeBridgeMode == jsToNativeModes.JS_OBJECT && msgs === \"@Null arguments.\") {\n        androidExec.setJsToNativeBridgeMode(jsToNativeModes.PROMPT);\n        androidExec(success, fail, service, action, args);\n        androidExec.setJsToNativeBridgeMode(jsToNativeModes.JS_OBJECT);\n    } else if (msgs) {\n        messagesFromNative.push(msgs);\n        // Always process async to avoid exceptions messing up stack.\n        nextTick(processMessages);\n    }\n}\n\nandroidExec.init = function() {\n    bridgeSecret = +prompt('', 'gap_init:' + nativeToJsBridgeMode);\n    channel.onNativeReady.fire();\n};\n\nfunction pollOnceFromOnlineEvent() {\n    pollOnce(true);\n}\n\nfunction pollOnce(opt_fromOnlineEvent) {\n    if (bridgeSecret < 0) {\n        // This can happen when the NativeToJsMessageQueue resets the online state on page transitions.\n        // We know there's nothing to retrieve, so no need to poll.\n        return;\n    }\n    var msgs = nativeApiProvider.get().retrieveJsMessages(bridgeSecret, !!opt_fromOnlineEvent);\n    if (msgs) {\n        messagesFromNative.push(msgs);\n        // Process sync since we know we're already top-of-stack.\n        processMessages();\n    }\n}\n\nfunction pollingTimerFunc() {\n    if (pollEnabled) {\n        pollOnce();\n        setTimeout(pollingTimerFunc, 50);\n    }\n}\n\nfunction hookOnlineApis() {\n    function proxyEvent(e) {\n        cordova.fireWindowEvent(e.type);\n    }\n    // The network module takes care of firing online and offline events.\n    // It currently fires them only on document though, so we bridge them\n    // to window here (while first listening for exec()-releated online/offline\n    // events).\n    window.addEventListener('online', pollOnceFromOnlineEvent, false);\n    window.addEventListener('offline', pollOnceFromOnlineEvent, false);\n    cordova.addWindowEventHandler('online');\n    cordova.addWindowEventHandler('offline');\n    document.addEventListener('online', proxyEvent, false);\n    document.addEventListener('offline', proxyEvent, false);\n}\n\nhookOnlineApis();\n\nandroidExec.jsToNativeModes = jsToNativeModes;\nandroidExec.nativeToJsModes = nativeToJsModes;\n\nandroidExec.setJsToNativeBridgeMode = function(mode) {\n    if (mode == jsToNativeModes.JS_OBJECT && !window._cordovaNative) {\n        mode = jsToNativeModes.PROMPT;\n    }\n    nativeApiProvider.setPreferPrompt(mode == jsToNativeModes.PROMPT);\n    jsToNativeBridgeMode = mode;\n};\n\nandroidExec.setNativeToJsBridgeMode = function(mode) {\n    if (mode == nativeToJsBridgeMode) {\n        return;\n    }\n    if (nativeToJsBridgeMode == nativeToJsModes.POLLING) {\n        pollEnabled = false;\n    }\n\n    nativeToJsBridgeMode = mode;\n    // Tell the native side to switch modes.\n    // Otherwise, it will be set by androidExec.init()\n    if (bridgeSecret >= 0) {\n        nativeApiProvider.get().setNativeToJsBridgeMode(bridgeSecret, mode);\n    }\n\n    if (mode == nativeToJsModes.POLLING) {\n        pollEnabled = true;\n        setTimeout(pollingTimerFunc, 1);\n    }\n};\n\nfunction buildPayload(payload, message) {\n    var payloadKind = message.charAt(0);\n    if (payloadKind == 's') {\n        payload.push(message.slice(1));\n    } else if (payloadKind == 't') {\n        payload.push(true);\n    } else if (payloadKind == 'f') {\n        payload.push(false);\n    } else if (payloadKind == 'N') {\n        payload.push(null);\n    } else if (payloadKind == 'n') {\n        payload.push(+message.slice(1));\n    } else if (payloadKind == 'A') {\n        var data = message.slice(1);\n        payload.push(base64.toArrayBuffer(data));\n    } else if (payloadKind == 'S') {\n        payload.push(window.atob(message.slice(1)));\n    } else if (payloadKind == 'M') {\n        var multipartMessages = message.slice(1);\n        while (multipartMessages !== \"\") {\n            var spaceIdx = multipartMessages.indexOf(' ');\n            var msgLen = +multipartMessages.slice(0, spaceIdx);\n            var multipartMessage = multipartMessages.substr(spaceIdx + 1, msgLen);\n            multipartMessages = multipartMessages.slice(spaceIdx + msgLen + 1);\n            buildPayload(payload, multipartMessage);\n        }\n    } else {\n        payload.push(JSON.parse(message));\n    }\n}\n\n// Processes a single message, as encoded by NativeToJsMessageQueue.java.\nfunction processMessage(message) {\n    var firstChar = message.charAt(0);\n    if (firstChar == 'J') {\n        // This is deprecated on the .java side. It doesn't work with CSP enabled.\n        eval(message.slice(1));\n    } else if (firstChar == 'S' || firstChar == 'F') {\n        var success = firstChar == 'S';\n        var keepCallback = message.charAt(1) == '1';\n        var spaceIdx = message.indexOf(' ', 2);\n        var status = +message.slice(2, spaceIdx);\n        var nextSpaceIdx = message.indexOf(' ', spaceIdx + 1);\n        var callbackId = message.slice(spaceIdx + 1, nextSpaceIdx);\n        var payloadMessage = message.slice(nextSpaceIdx + 1);\n        var payload = [];\n        buildPayload(payload, payloadMessage);\n        cordova.callbackFromNative(callbackId, success, status, payload, keepCallback);\n    } else {\n        console.log(\"processMessage failed: invalid message: \" + JSON.stringify(message));\n    }\n}\n\nfunction processMessages() {\n    // Check for the reentrant case.\n    if (isProcessing) {\n        return;\n    }\n    if (messagesFromNative.length === 0) {\n        return;\n    }\n    isProcessing = true;\n    try {\n        var msg = popMessageFromQueue();\n        // The Java side can send a * message to indicate that it\n        // still has messages waiting to be retrieved.\n        if (msg == '*' && messagesFromNative.length === 0) {\n            nextTick(pollOnce);\n            return;\n        }\n        processMessage(msg);\n    } finally {\n        isProcessing = false;\n        if (messagesFromNative.length > 0) {\n            nextTick(processMessages);\n        }\n    }\n}\n\nfunction popMessageFromQueue() {\n    var messageBatch = messagesFromNative.shift();\n    if (messageBatch == '*') {\n        return '*';\n    }\n\n    var spaceIdx = messageBatch.indexOf(' ');\n    var msgLen = +messageBatch.slice(0, spaceIdx);\n    var message = messageBatch.substr(spaceIdx + 1, msgLen);\n    messageBatch = messageBatch.slice(spaceIdx + msgLen + 1);\n    if (messageBatch) {\n        messagesFromNative.unshift(messageBatch);\n    }\n    return message;\n}\n\nmodule.exports = androidExec;\n\n},{\"cordova\":\"cordova\",\"cordova/android/nativeapiprovider\":\"cordova/android/nativeapiprovider\",\"cordova/base64\":\"cordova/base64\",\"cordova/channel\":\"cordova/channel\",\"cordova/utils\":\"cordova/utils\"}],\"cordova/init\":[function(require,module,exports){\n/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\nvar channel = require('cordova/channel');\nvar cordova = require('cordova');\nvar modulemapper = require('cordova/modulemapper');\nvar platform = require('cordova/platform');\nvar pluginloader = require('cordova/pluginloader');\nvar utils = require('cordova/utils');\n\nvar platformInitChannelsArray = [channel.onDOMContentLoaded, channel.onNativeReady, channel.onPluginsReady];\n\n// setting exec\ncordova.exec = require('cordova/exec');\n\nfunction logUnfiredChannels(arr) {\n    for (var i = 0; i < arr.length; ++i) {\n        if (arr[i].state != 2) {\n            console.log('Channel not fired: ' + arr[i].type);\n        }\n    }\n}\n\nwindow.setTimeout(function() {\n    if (channel.onDeviceReady.state != 2) {\n        console.log('deviceready has not fired after 5 seconds.');\n        logUnfiredChannels(platformInitChannelsArray);\n        logUnfiredChannels(channel.deviceReadyChannelsArray);\n    }\n}, 5000);\n\n// Replace navigator before any modules are required(), to ensure it happens as soon as possible.\n// We replace it so that properties that can't be clobbered can instead be overridden.\nfunction replaceNavigator(origNavigator) {\n    var CordovaNavigator = function() {};\n    CordovaNavigator.prototype = origNavigator;\n    var newNavigator = new CordovaNavigator();\n    // This work-around really only applies to new APIs that are newer than Function.bind.\n    // Without it, APIs such as getGamepads() break.\n    if (CordovaNavigator.bind) {\n        for (var key in origNavigator) {\n            if (typeof origNavigator[key] == 'function') {\n                newNavigator[key] = origNavigator[key].bind(origNavigator);\n            }\n            else {\n                (function(k) {\n                    utils.defineGetterSetter(newNavigator,key,function() {\n                        return origNavigator[k];\n                    });\n                })(key);\n            }\n        }\n    }\n    return newNavigator;\n}\nif (window.navigator) {\n    window.navigator = replaceNavigator(window.navigator);\n}\n\nif (!window.console) {\n    window.console = {\n        log: function(){}\n    };\n}\nif (!window.console.warn) {\n    window.console.warn = function(msg) {\n        this.log(\"warn: \" + msg);\n    };\n}\n\n// Register pause, resume and deviceready channels as events on document.\nchannel.onPause = cordova.addDocumentEventHandler('pause');\nchannel.onResume = cordova.addDocumentEventHandler('resume');\nchannel.onActivated = cordova.addDocumentEventHandler('activated');\nchannel.onDeviceReady = cordova.addStickyDocumentEventHandler('deviceready');\n\n// Listen for DOMContentLoaded and notify our channel subscribers.\nif (document.readyState == 'complete' || document.readyState == 'interactive') {\n    channel.onDOMContentLoaded.fire();\n} else {\n    document.addEventListener('DOMContentLoaded', function() {\n        channel.onDOMContentLoaded.fire();\n    }, false);\n}\n\n// _nativeReady is global variable that the native side can set\n// to signify that the native code is ready. It is a global since\n// it may be called before any cordova JS is ready.\nif (window._nativeReady) {\n    channel.onNativeReady.fire();\n}\n\n// Call the platform-specific initialization.\nplatform.bootstrap && platform.bootstrap();\n\n// Wrap in a setTimeout to support the use-case of having plugin JS appended to cordova.js.\n// The delay allows the attached modules to be defined before the plugin loader looks for them.\nsetTimeout(function() {\n    pluginloader.load(function() {\n        channel.onPluginsReady.fire();\n    });\n}, 0);\n\n/**\n * Create all cordova objects once native side is ready.\n */\nchannel.join(function() {\n    modulemapper.mapModules(window);\n\n    platform.initialize && platform.initialize();\n\n    // Fire event to notify that all objects are created\n    channel.onCordovaReady.fire();\n\n    // Fire onDeviceReady event once page has fully loaded, all\n    // constructors have run and cordova info has been received from native\n    // side.\n    channel.join(function() {\n        require('cordova').fireDocumentEvent('deviceready');\n    }, channel.deviceReadyChannelsArray);\n\n}, platformInitChannelsArray);\n\n},{\"cordova\":\"cordova\",\"cordova/channel\":\"cordova/channel\",\"cordova/exec\":\"cordova/exec\",\"cordova/modulemapper\":\"cordova/modulemapper\",\"cordova/platform\":\"cordova/platform\",\"cordova/pluginloader\":\"cordova/pluginloader\",\"cordova/utils\":\"cordova/utils\"}],\"cordova/modulemapper\":[function(require,module,exports){\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\nvar builder = require('cordova/builder'),\n    symbolList = [],\n    deprecationMap;\n\nexports.reset = function() {\n    symbolList = [];\n    deprecationMap = {};\n};\n\nfunction addEntry(strategy, moduleName, symbolPath, opt_deprecationMessage) {\n    symbolList.push(strategy, moduleName, symbolPath);\n    if (opt_deprecationMessage) {\n        deprecationMap[symbolPath] = opt_deprecationMessage;\n    }\n}\n\n// Note: Android 2.3 does have Function.bind().\nexports.clobbers = function(moduleName, symbolPath, opt_deprecationMessage) {\n    addEntry('c', moduleName, symbolPath, opt_deprecationMessage);\n};\n\nexports.merges = function(moduleName, symbolPath, opt_deprecationMessage) {\n    addEntry('m', moduleName, symbolPath, opt_deprecationMessage);\n};\n\nexports.defaults = function(moduleName, symbolPath, opt_deprecationMessage) {\n    addEntry('d', moduleName, symbolPath, opt_deprecationMessage);\n};\n\nexports.runs = function(moduleName) {\n    addEntry('r', moduleName, null);\n};\n\nfunction prepareNamespace(symbolPath, context) {\n    if (!symbolPath) {\n        return context;\n    }\n    var parts = symbolPath.split('.');\n    var cur = context;\n    for (var i = 0, part; part = parts[i]; ++i) {\n        cur = cur[part] = cur[part] || {};\n    }\n    return cur;\n}\n\nexports.mapModules = function(context) {\n    var origSymbols = {};\n    context.CDV_origSymbols = origSymbols;\n    for (var i = 0, len = symbolList.length; i < len; i += 3) {\n        var strategy = symbolList[i];\n        var moduleName = symbolList[i + 1];\n        var module = require(moduleName);\n        // <runs/>\n        if (strategy == 'r') {\n            continue;\n        }\n        var symbolPath = symbolList[i + 2];\n        var lastDot = symbolPath.lastIndexOf('.');\n        var namespace = symbolPath.substr(0, lastDot);\n        var lastName = symbolPath.substr(lastDot + 1);\n\n        var deprecationMsg = symbolPath in deprecationMap ? 'Access made to deprecated symbol: ' + symbolPath + '. ' + deprecationMsg : null;\n        var parentObj = prepareNamespace(namespace, context);\n        var target = parentObj[lastName];\n\n        if (strategy == 'm' && target) {\n            builder.recursiveMerge(target, module);\n        } else if ((strategy == 'd' && !target) || (strategy != 'd')) {\n            if (!(symbolPath in origSymbols)) {\n                origSymbols[symbolPath] = target;\n            }\n            builder.assignOrWrapInDeprecateGetter(parentObj, lastName, module, deprecationMsg);\n        }\n    }\n};\n\nexports.getOriginalSymbol = function(context, symbolPath) {\n    var origSymbols = context.CDV_origSymbols;\n    if (origSymbols && (symbolPath in origSymbols)) {\n        return origSymbols[symbolPath];\n    }\n    var parts = symbolPath.split('.');\n    var obj = context;\n    for (var i = 0; i < parts.length; ++i) {\n        obj = obj && obj[parts[i]];\n    }\n    return obj;\n};\n\nexports.reset();\n\n\n},{\"cordova/builder\":\"cordova/builder\"}],\"cordova/platform\":[function(require,module,exports){\n/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n// The last resume event that was received that had the result of a plugin call.\nvar lastResumeEvent = null;\n\nmodule.exports = {\n    id: 'android',\n    bootstrap: function() {\n        var channel = require('cordova/channel'),\n            cordova = require('cordova'),\n            exec = require('cordova/exec'),\n            modulemapper = require('cordova/modulemapper');\n\n        // Get the shared secret needed to use the bridge.\n        exec.init();\n\n        // TODO: Extract this as a proper plugin.\n        modulemapper.clobbers('cordova/plugin/android/app', 'navigator.app');\n\n        var APP_PLUGIN_NAME = Number(cordova.platformVersion.split('.')[0]) >= 4 ? 'CoreAndroid' : 'App';\n\n        // Inject a listener for the backbutton on the document.\n        var backButtonChannel = cordova.addDocumentEventHandler('backbutton');\n        backButtonChannel.onHasSubscribersChange = function() {\n            // If we just attached the first handler or detached the last handler,\n            // let native know we need to override the back button.\n            exec(null, null, APP_PLUGIN_NAME, \"overrideBackbutton\", [this.numHandlers == 1]);\n        };\n\n        // Add hardware MENU and SEARCH button handlers\n        cordova.addDocumentEventHandler('menubutton');\n        cordova.addDocumentEventHandler('searchbutton');\n\n        function bindButtonChannel(buttonName) {\n            // generic button bind used for volumeup/volumedown buttons\n            var volumeButtonChannel = cordova.addDocumentEventHandler(buttonName + 'button');\n            volumeButtonChannel.onHasSubscribersChange = function() {\n                exec(null, null, APP_PLUGIN_NAME, \"overrideButton\", [buttonName, this.numHandlers == 1]);\n            };\n        }\n        // Inject a listener for the volume buttons on the document.\n        bindButtonChannel('volumeup');\n        bindButtonChannel('volumedown');\n\n        // The resume event is not \"sticky\", but it is possible that the event\n        // will contain the result of a plugin call. We need to ensure that the\n        // plugin result is delivered even after the event is fired (CB-10498)\n        var cordovaAddEventListener = document.addEventListener;\n\n        document.addEventListener = function(evt, handler, capture) {\n            cordovaAddEventListener(evt, handler, capture);\n\n            if (evt === 'resume' && lastResumeEvent) {\n                handler(lastResumeEvent);\n            }\n        };\n\n        // Let native code know we are all done on the JS side.\n        // Native code will then un-hide the WebView.\n        channel.onCordovaReady.subscribe(function() {\n            exec(onMessageFromNative, null, APP_PLUGIN_NAME, 'messageChannel', []);\n            exec(null, null, APP_PLUGIN_NAME, \"show\", []);\n        });\n    }\n};\n\nfunction onMessageFromNative(msg) {\n    var cordova = require('cordova');\n    var action = msg.action;\n\n    switch (action)\n    {\n        // Button events\n        case 'backbutton':\n        case 'menubutton':\n        case 'searchbutton':\n        // App life cycle events\n        case 'pause':\n        // Volume events\n        case 'volumedownbutton':\n        case 'volumeupbutton':\n            cordova.fireDocumentEvent(action);\n            break;\n        case 'resume':\n            if(arguments.length > 1 && msg.pendingResult) {\n                if(arguments.length === 2) {\n                    msg.pendingResult.result = arguments[1];\n                } else {\n                    // The plugin returned a multipart message\n                    var res = [];\n                    for(var i = 1; i < arguments.length; i++) {\n                        res.push(arguments[i]);\n                    }\n                    msg.pendingResult.result = res;\n                }\n\n                // Save the plugin result so that it can be delivered to the js\n                // even if they miss the initial firing of the event\n                lastResumeEvent = msg;\n            }\n            cordova.fireDocumentEvent(action, msg);\n            break;\n        default:\n            throw new Error('Unknown event action ' + action);\n    }\n}\n\n},{\"cordova\":\"cordova\",\"cordova/channel\":\"cordova/channel\",\"cordova/exec\":\"cordova/exec\",\"cordova/modulemapper\":\"cordova/modulemapper\"}],\"cordova/plugin/android/app\":[function(require,module,exports){\n/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\nvar exec = require('cordova/exec');\nvar APP_PLUGIN_NAME = Number(require('cordova').platformVersion.split('.')[0]) >= 4 ? 'CoreAndroid' : 'App';\n\nmodule.exports = {\n    /**\n    * Clear the resource cache.\n    */\n    clearCache:function() {\n        exec(null, null, APP_PLUGIN_NAME, \"clearCache\", []);\n    },\n\n    /**\n    * Load the url into the webview or into new browser instance.\n    *\n    * @param url           The URL to load\n    * @param props         Properties that can be passed in to the activity:\n    *      wait: int                           => wait msec before loading URL\n    *      loadingDialog: \"Title,Message\"      => display a native loading dialog\n    *      loadUrlTimeoutValue: int            => time in msec to wait before triggering a timeout error\n    *      clearHistory: boolean              => clear webview history (default=false)\n    *      openExternal: boolean              => open in a new browser (default=false)\n    *\n    * Example:\n    *      navigator.app.loadUrl(\"http://server/myapp/index.html\", {wait:2000, loadingDialog:\"Wait,Loading App\", loadUrlTimeoutValue: 60000});\n    */\n    loadUrl:function(url, props) {\n        exec(null, null, APP_PLUGIN_NAME, \"loadUrl\", [url, props]);\n    },\n\n    /**\n    * Cancel loadUrl that is waiting to be loaded.\n    */\n    cancelLoadUrl:function() {\n        exec(null, null, APP_PLUGIN_NAME, \"cancelLoadUrl\", []);\n    },\n\n    /**\n    * Clear web history in this web view.\n    * Instead of BACK button loading the previous web page, it will exit the app.\n    */\n    clearHistory:function() {\n        exec(null, null, APP_PLUGIN_NAME, \"clearHistory\", []);\n    },\n\n    /**\n    * Go to previous page displayed.\n    * This is the same as pressing the backbutton on Android device.\n    */\n    backHistory:function() {\n        exec(null, null, APP_PLUGIN_NAME, \"backHistory\", []);\n    },\n\n    /**\n    * Override the default behavior of the Android back button.\n    * If overridden, when the back button is pressed, the \"backKeyDown\" JavaScript event will be fired.\n    *\n    * Note: The user should not have to call this method.  Instead, when the user\n    *       registers for the \"backbutton\" event, this is automatically done.\n    *\n    * @param override        T=override, F=cancel override\n    */\n    overrideBackbutton:function(override) {\n        exec(null, null, APP_PLUGIN_NAME, \"overrideBackbutton\", [override]);\n    },\n\n    /**\n    * Override the default behavior of the Android volume button.\n    * If overridden, when the volume button is pressed, the \"volume[up|down]button\"\n    * JavaScript event will be fired.\n    *\n    * Note: The user should not have to call this method.  Instead, when the user\n    *       registers for the \"volume[up|down]button\" event, this is automatically done.\n    *\n    * @param button          volumeup, volumedown\n    * @param override        T=override, F=cancel override\n    */\n    overrideButton:function(button, override) {\n        exec(null, null, APP_PLUGIN_NAME, \"overrideButton\", [button, override]);\n    },\n\n    /**\n    * Exit and terminate the application.\n    */\n    exitApp:function() {\n        return exec(null, null, APP_PLUGIN_NAME, \"exitApp\", []);\n    }\n};\n\n},{\"cordova\":\"cordova\",\"cordova/exec\":\"cordova/exec\"}],\"cordova/plugin_list\":[function(require,module,exports){\nmodule.exports.metadata = {\n    \"cordova-plugin-camera\": \"2.2.0\",\n    \"cordova-plugin-device\": \"1.1.2\",\n    \"cordova-plugin-device-orientation\": \"1.0.3\",\n    \"cordova-plugin-file-transfer\": \"1.5.1\",\n    \"cordova-plugin-inappbrowser\": \"1.4.0\",\n    \"cordova-plugin-network-information\": \"1.2.1\",\n    \"cordova-plugin-compat\": \"1.0.0\",\n    \"cordova-plugin-file\": \"4.2.0\"\n};\nmodule.exports = [\n    {\n        \"file\": \"www/CameraConstants.js\",\n        \"id\": \"cordova-plugin-camera.Camera\",\n        \"name\": \"Camera\",\n        \"pluginId\": \"cordova-plugin-camera\",\n        \"clobbers\": [\n            \"Camera\"\n        ]\n    },\n    {\n        \"file\": \"www/CameraPopoverOptions.js\",\n        \"id\": \"cordova-plugin-camera.CameraPopoverOptions\",\n        \"name\": \"CameraPopoverOptions\",\n        \"pluginId\": \"cordova-plugin-camera\",\n        \"clobbers\": [\n            \"CameraPopoverOptions\"\n        ]\n    },\n    {\n        \"file\": \"www/Camera.js\",\n        \"id\": \"cordova-plugin-camera.camera\",\n        \"name\": \"camera\",\n        \"pluginId\": \"cordova-plugin-camera\",\n        \"clobbers\": [\n            \"navigator.camera\"\n        ]\n    },\n    {\n        \"file\": \"www/CameraPopoverHandle.js\",\n        \"id\": \"cordova-plugin-camera.CameraPopoverHandle\",\n        \"name\": \"CameraPopoverHandle\",\n        \"pluginId\": \"cordova-plugin-camera\",\n        \"clobbers\": [\n            \"CameraPopoverHandle\"\n        ]\n    },\n    {\n        \"file\": \"www/device.js\",\n        \"id\": \"cordova-plugin-device.device\",\n        \"name\": \"device\",\n        \"pluginId\": \"cordova-plugin-device\",\n        \"clobbers\": [\n            \"device\"\n        ]\n    },\n    {\n        \"file\": \"www/CompassError.js\",\n        \"id\": \"cordova-plugin-device-orientation.CompassError\",\n        \"name\": \"CompassError\",\n        \"pluginId\": \"cordova-plugin-device-orientation\",\n        \"clobbers\": [\n            \"CompassError\"\n        ]\n    },\n    {\n        \"file\": \"www/CompassHeading.js\",\n        \"id\": \"cordova-plugin-device-orientation.CompassHeading\",\n        \"name\": \"CompassHeading\",\n        \"pluginId\": \"cordova-plugin-device-orientation\",\n        \"clobbers\": [\n            \"CompassHeading\"\n        ]\n    },\n    {\n        \"file\": \"www/compass.js\",\n        \"id\": \"cordova-plugin-device-orientation.compass\",\n        \"name\": \"compass\",\n        \"pluginId\": \"cordova-plugin-device-orientation\",\n        \"clobbers\": [\n            \"navigator.compass\"\n        ]\n    },\n    {\n        \"file\": \"www/FileTransferError.js\",\n        \"id\": \"cordova-plugin-file-transfer.FileTransferError\",\n        \"name\": \"FileTransferError\",\n        \"pluginId\": \"cordova-plugin-file-transfer\",\n        \"clobbers\": [\n            \"window.FileTransferError\"\n        ]\n    },\n    {\n        \"file\": \"www/FileTransfer.js\",\n        \"id\": \"cordova-plugin-file-transfer.FileTransfer\",\n        \"name\": \"FileTransfer\",\n        \"pluginId\": \"cordova-plugin-file-transfer\",\n        \"clobbers\": [\n            \"window.FileTransfer\"\n        ]\n    },\n    {\n        \"file\": \"www/inappbrowser.js\",\n        \"id\": \"cordova-plugin-inappbrowser.inappbrowser\",\n        \"name\": \"inappbrowser\",\n        \"pluginId\": \"cordova-plugin-inappbrowser\",\n        \"clobbers\": [\n            \"cordova.InAppBrowser.open\",\n            \"window.open\"\n        ]\n    },\n    {\n        \"file\": \"www/network.js\",\n        \"id\": \"cordova-plugin-network-information.network\",\n        \"name\": \"network\",\n        \"pluginId\": \"cordova-plugin-network-information\",\n        \"clobbers\": [\n            \"navigator.connection\",\n            \"navigator.network.connection\"\n        ]\n    },\n    {\n        \"file\": \"www/Connection.js\",\n        \"id\": \"cordova-plugin-network-information.Connection\",\n        \"name\": \"Connection\",\n        \"pluginId\": \"cordova-plugin-network-information\",\n        \"clobbers\": [\n            \"Connection\"\n        ]\n    },\n    {\n        \"file\": \"www/DirectoryEntry.js\",\n        \"id\": \"cordova-plugin-file.DirectoryEntry\",\n        \"name\": \"DirectoryEntry\",\n        \"pluginId\": \"cordova-plugin-file\",\n        \"clobbers\": [\n            \"window.DirectoryEntry\"\n        ]\n    },\n    {\n        \"file\": \"www/DirectoryReader.js\",\n        \"id\": \"cordova-plugin-file.DirectoryReader\",\n        \"name\": \"DirectoryReader\",\n        \"pluginId\": \"cordova-plugin-file\",\n        \"clobbers\": [\n            \"window.DirectoryReader\"\n        ]\n    },\n    {\n        \"file\": \"www/Entry.js\",\n        \"id\": \"cordova-plugin-file.Entry\",\n        \"name\": \"Entry\",\n        \"pluginId\": \"cordova-plugin-file\",\n        \"clobbers\": [\n            \"window.Entry\"\n        ]\n    },\n    {\n        \"file\": \"www/File.js\",\n        \"id\": \"cordova-plugin-file.File\",\n        \"name\": \"File\",\n        \"pluginId\": \"cordova-plugin-file\",\n        \"clobbers\": [\n            \"window.File\"\n        ]\n    },\n    {\n        \"file\": \"www/FileEntry.js\",\n        \"id\": \"cordova-plugin-file.FileEntry\",\n        \"name\": \"FileEntry\",\n        \"pluginId\": \"cordova-plugin-file\",\n        \"clobbers\": [\n            \"window.FileEntry\"\n        ]\n    },\n    {\n        \"file\": \"www/FileError.js\",\n        \"id\": \"cordova-plugin-file.FileError\",\n        \"name\": \"FileError\",\n        \"pluginId\": \"cordova-plugin-file\",\n        \"clobbers\": [\n            \"window.FileError\"\n        ]\n    },\n    {\n        \"file\": \"www/FileReader.js\",\n        \"id\": \"cordova-plugin-file.FileReader\",\n        \"name\": \"FileReader\",\n        \"pluginId\": \"cordova-plugin-file\",\n        \"clobbers\": [\n            \"window.FileReader\"\n        ]\n    },\n    {\n        \"file\": \"www/FileSystem.js\",\n        \"id\": \"cordova-plugin-file.FileSystem\",\n        \"name\": \"FileSystem\",\n        \"pluginId\": \"cordova-plugin-file\",\n        \"clobbers\": [\n            \"window.FileSystem\"\n        ]\n    },\n    {\n        \"file\": \"www/FileUploadOptions.js\",\n        \"id\": \"cordova-plugin-file.FileUploadOptions\",\n        \"name\": \"FileUploadOptions\",\n        \"pluginId\": \"cordova-plugin-file\",\n        \"clobbers\": [\n            \"window.FileUploadOptions\"\n        ]\n    },\n    {\n        \"file\": \"www/FileUploadResult.js\",\n        \"id\": \"cordova-plugin-file.FileUploadResult\",\n        \"name\": \"FileUploadResult\",\n        \"pluginId\": \"cordova-plugin-file\",\n        \"clobbers\": [\n            \"window.FileUploadResult\"\n        ]\n    },\n    {\n        \"file\": \"www/FileWriter.js\",\n        \"id\": \"cordova-plugin-file.FileWriter\",\n        \"name\": \"FileWriter\",\n        \"pluginId\": \"cordova-plugin-file\",\n        \"clobbers\": [\n            \"window.FileWriter\"\n        ]\n    },\n    {\n        \"file\": \"www/Flags.js\",\n        \"id\": \"cordova-plugin-file.Flags\",\n        \"name\": \"Flags\",\n        \"pluginId\": \"cordova-plugin-file\",\n        \"clobbers\": [\n            \"window.Flags\"\n        ]\n    },\n    {\n        \"file\": \"www/LocalFileSystem.js\",\n        \"id\": \"cordova-plugin-file.LocalFileSystem\",\n        \"name\": \"LocalFileSystem\",\n        \"pluginId\": \"cordova-plugin-file\",\n        \"clobbers\": [\n            \"window.LocalFileSystem\"\n        ],\n        \"merges\": [\n            \"window\"\n        ]\n    },\n    {\n        \"file\": \"www/Metadata.js\",\n        \"id\": \"cordova-plugin-file.Metadata\",\n        \"name\": \"Metadata\",\n        \"pluginId\": \"cordova-plugin-file\",\n        \"clobbers\": [\n            \"window.Metadata\"\n        ]\n    },\n    {\n        \"file\": \"www/ProgressEvent.js\",\n        \"id\": \"cordova-plugin-file.ProgressEvent\",\n        \"name\": \"ProgressEvent\",\n        \"pluginId\": \"cordova-plugin-file\",\n        \"clobbers\": [\n            \"window.ProgressEvent\"\n        ]\n    },\n    {\n        \"file\": \"www/fileSystems.js\",\n        \"id\": \"cordova-plugin-file.fileSystems\",\n        \"name\": \"fileSystems\",\n        \"pluginId\": \"cordova-plugin-file\"\n    },\n    {\n        \"file\": \"www/requestFileSystem.js\",\n        \"id\": \"cordova-plugin-file.requestFileSystem\",\n        \"name\": \"requestFileSystem\",\n        \"pluginId\": \"cordova-plugin-file\",\n        \"clobbers\": [\n            \"window.requestFileSystem\"\n        ]\n    },\n    {\n        \"file\": \"www/resolveLocalFileSystemURI.js\",\n        \"id\": \"cordova-plugin-file.resolveLocalFileSystemURI\",\n        \"name\": \"resolveLocalFileSystemURI\",\n        \"pluginId\": \"cordova-plugin-file\",\n        \"merges\": [\n            \"window\"\n        ]\n    },\n    {\n        \"file\": \"www/browser/isChrome.js\",\n        \"id\": \"cordova-plugin-file.isChrome\",\n        \"name\": \"isChrome\",\n        \"pluginId\": \"cordova-plugin-file\",\n        \"runs\": true\n    },\n    {\n        \"file\": \"www/android/FileSystem.js\",\n        \"id\": \"cordova-plugin-file.androidFileSystem\",\n        \"name\": \"androidFileSystem\",\n        \"pluginId\": \"cordova-plugin-file\",\n        \"merges\": [\n            \"FileSystem\"\n        ]\n    },\n    {\n        \"file\": \"www/fileSystems-roots.js\",\n        \"id\": \"cordova-plugin-file.fileSystems-roots\",\n        \"name\": \"fileSystems-roots\",\n        \"pluginId\": \"cordova-plugin-file\",\n        \"runs\": true\n    },\n    {\n        \"file\": \"www/fileSystemPaths.js\",\n        \"id\": \"cordova-plugin-file.fileSystemPaths\",\n        \"name\": \"fileSystemPaths\",\n        \"pluginId\": \"cordova-plugin-file\",\n        \"merges\": [\n            \"cordova\"\n        ],\n        \"runs\": true\n    }\n];\n\n},{}],\"cordova/pluginloader\":[function(require,module,exports){\n/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\nvar modulemapper = require('cordova/modulemapper');\n\n// Handler for the cordova_plugins.js content.\n// See plugman's plugin_loader.js for the details of this object.\nfunction handlePluginsObject(moduleList) {\n    // if moduleList is not defined or empty, we've nothing to do\n    if (!moduleList || !moduleList.length) {\n        return;\n    }\n\n    // Loop through all the modules and then through their clobbers and merges.\n    for (var i = 0, module; module = moduleList[i]; i++) {\n        if (module.clobbers && module.clobbers.length) {\n            for (var j = 0; j < module.clobbers.length; j++) {\n                modulemapper.clobbers(module.id, module.clobbers[j]);\n            }\n        }\n\n        if (module.merges && module.merges.length) {\n            for (var k = 0; k < module.merges.length; k++) {\n                modulemapper.merges(module.id, module.merges[k]);\n            }\n        }\n\n        // Finally, if runs is truthy we want to simply require() the module.\n        if (module.runs) {\n            modulemapper.runs(module.id);\n        }\n    }\n}\n\n// Loads all plugins' js-modules. Plugin loading is syncronous in browserified bundle\n// but the method accepts callback to be compatible with non-browserify flow.\n// onDeviceReady is blocked on onPluginsReady. onPluginsReady is fired when there are\n// no plugins to load, or they are all done.\nexports.load = function(callback) {\n    var moduleList = require(\"cordova/plugin_list\");\n    handlePluginsObject(moduleList);\n\n    callback();\n};\n\n\n},{\"cordova/modulemapper\":\"cordova/modulemapper\",\"cordova/plugin_list\":\"cordova/plugin_list\"}],\"cordova/urlutil\":[function(require,module,exports){\n/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n\n/**\n * For already absolute URLs, returns what is passed in.\n * For relative URLs, converts them to absolute ones.\n */\nexports.makeAbsolute = function makeAbsolute(url) {\n    var anchorEl = document.createElement('a');\n    anchorEl.href = url;\n    return anchorEl.href;\n};\n\n\n},{}],\"cordova/utils\":[function(require,module,exports){\n/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\nvar utils = exports;\n\n/**\n * Defines a property getter / setter for obj[key].\n */\nutils.defineGetterSetter = function(obj, key, getFunc, opt_setFunc) {\n    if (Object.defineProperty) {\n        var desc = {\n            get: getFunc,\n            configurable: true\n        };\n        if (opt_setFunc) {\n            desc.set = opt_setFunc;\n        }\n        Object.defineProperty(obj, key, desc);\n    } else {\n        obj.__defineGetter__(key, getFunc);\n        if (opt_setFunc) {\n            obj.__defineSetter__(key, opt_setFunc);\n        }\n    }\n};\n\n/**\n * Defines a property getter for obj[key].\n */\nutils.defineGetter = utils.defineGetterSetter;\n\nutils.arrayIndexOf = function(a, item) {\n    if (a.indexOf) {\n        return a.indexOf(item);\n    }\n    var len = a.length;\n    for (var i = 0; i < len; ++i) {\n        if (a[i] == item) {\n            return i;\n        }\n    }\n    return -1;\n};\n\n/**\n * Returns whether the item was found in the array.\n */\nutils.arrayRemove = function(a, item) {\n    var index = utils.arrayIndexOf(a, item);\n    if (index != -1) {\n        a.splice(index, 1);\n    }\n    return index != -1;\n};\n\nutils.typeName = function(val) {\n    return Object.prototype.toString.call(val).slice(8, -1);\n};\n\n/**\n * Returns an indication of whether the argument is an array or not\n */\nutils.isArray = Array.isArray ||\n                function(a) {return utils.typeName(a) == 'Array';};\n\n/**\n * Returns an indication of whether the argument is a Date or not\n */\nutils.isDate = function(d) {\n    return (d instanceof Date);\n};\n\n/**\n * Does a deep clone of the object.\n */\nutils.clone = function(obj) {\n    if(!obj || typeof obj == 'function' || utils.isDate(obj) || typeof obj != 'object') {\n        return obj;\n    }\n\n    var retVal, i;\n\n    if(utils.isArray(obj)){\n        retVal = [];\n        for(i = 0; i < obj.length; ++i){\n            retVal.push(utils.clone(obj[i]));\n        }\n        return retVal;\n    }\n\n    retVal = {};\n    for(i in obj){\n        if(!(i in retVal) || retVal[i] != obj[i]) {\n            retVal[i] = utils.clone(obj[i]);\n        }\n    }\n    return retVal;\n};\n\n/**\n * Returns a wrapped version of the function\n */\nutils.close = function(context, func, params) {\n    return function() {\n        var args = params || arguments;\n        return func.apply(context, args);\n    };\n};\n\n//------------------------------------------------------------------------------\nfunction UUIDcreatePart(length) {\n    var uuidpart = \"\";\n    for (var i=0; i<length; i++) {\n        var uuidchar = parseInt((Math.random() * 256), 10).toString(16);\n        if (uuidchar.length == 1) {\n            uuidchar = \"0\" + uuidchar;\n        }\n        uuidpart += uuidchar;\n    }\n    return uuidpart;\n}\n\n/**\n * Create a UUID\n */\nutils.createUUID = function() {\n    return UUIDcreatePart(4) + '-' +\n        UUIDcreatePart(2) + '-' +\n        UUIDcreatePart(2) + '-' +\n        UUIDcreatePart(2) + '-' +\n        UUIDcreatePart(6);\n};\n\n\n/**\n * Extends a child object from a parent object using classical inheritance\n * pattern.\n */\nutils.extend = (function() {\n    // proxy used to establish prototype chain\n    var F = function() {};\n    // extend Child from Parent\n    return function(Child, Parent) {\n\n        F.prototype = Parent.prototype;\n        Child.prototype = new F();\n        Child.__super__ = Parent.prototype;\n        Child.prototype.constructor = Child;\n    };\n}());\n\n/**\n * Alerts a message in any available way: alert or console.log.\n */\nutils.alert = function(msg) {\n    if (window.alert) {\n        window.alert(msg);\n    } else if (console && console.log) {\n        console.log(msg);\n    }\n};\n\n\n\n\n\n},{}],\"cordova\":[function(require,module,exports){\n/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n// Workaround for Windows 10 in hosted environment case\n// http://www.w3.org/html/wg/drafts/html/master/browsers.html#named-access-on-the-window-object\nif (window.cordova && !(window.cordova instanceof HTMLElement)) {\n    throw new Error(\"cordova already defined\");\n}\n\n/*global symbolList*/\n\nvar channel = require('cordova/channel');\nvar platform = require('cordova/platform');\n\n/**\n * Intercept calls to addEventListener + removeEventListener and handle deviceready,\n * resume, and pause events.\n */\nvar m_document_addEventListener = document.addEventListener;\nvar m_document_removeEventListener = document.removeEventListener;\nvar m_window_addEventListener = window.addEventListener;\nvar m_window_removeEventListener = window.removeEventListener;\n\n/**\n * Houses custom event handlers to intercept on document + window event listeners.\n */\nvar documentEventHandlers = {},\n    windowEventHandlers = {};\n\ndocument.addEventListener = function(evt, handler, capture) {\n    var e = evt.toLowerCase();\n    if (typeof documentEventHandlers[e] != 'undefined') {\n        documentEventHandlers[e].subscribe(handler);\n    } else {\n        m_document_addEventListener.call(document, evt, handler, capture);\n    }\n};\n\nwindow.addEventListener = function(evt, handler, capture) {\n    var e = evt.toLowerCase();\n    if (typeof windowEventHandlers[e] != 'undefined') {\n        windowEventHandlers[e].subscribe(handler);\n    } else {\n        m_window_addEventListener.call(window, evt, handler, capture);\n    }\n};\n\ndocument.removeEventListener = function(evt, handler, capture) {\n    var e = evt.toLowerCase();\n    // If unsubscribing from an event that is handled by a plugin\n    if (typeof documentEventHandlers[e] != \"undefined\") {\n        documentEventHandlers[e].unsubscribe(handler);\n    } else {\n        m_document_removeEventListener.call(document, evt, handler, capture);\n    }\n};\n\nwindow.removeEventListener = function(evt, handler, capture) {\n    var e = evt.toLowerCase();\n    // If unsubscribing from an event that is handled by a plugin\n    if (typeof windowEventHandlers[e] != \"undefined\") {\n        windowEventHandlers[e].unsubscribe(handler);\n    } else {\n        m_window_removeEventListener.call(window, evt, handler, capture);\n    }\n};\n\nfunction createEvent(type, data) {\n    var event = document.createEvent('Events');\n    event.initEvent(type, false, false);\n    if (data) {\n        for (var i in data) {\n            if (data.hasOwnProperty(i)) {\n                event[i] = data[i];\n            }\n        }\n    }\n    return event;\n}\n\n\nvar cordova = {\n    platformVersion:PLATFORM_VERSION_BUILD_LABEL,\n    version:PLATFORM_VERSION_BUILD_LABEL,\n    require: require,\n    platformId:platform.id,\n    /**\n     * Methods to add/remove your own addEventListener hijacking on document + window.\n     */\n    addWindowEventHandler:function(event) {\n        return (windowEventHandlers[event] = channel.create(event));\n    },\n    addStickyDocumentEventHandler:function(event) {\n        return (documentEventHandlers[event] = channel.createSticky(event));\n    },\n    addDocumentEventHandler:function(event) {\n        return (documentEventHandlers[event] = channel.create(event));\n    },\n    removeWindowEventHandler:function(event) {\n        delete windowEventHandlers[event];\n    },\n    removeDocumentEventHandler:function(event) {\n        delete documentEventHandlers[event];\n    },\n    /**\n     * Retrieve original event handlers that were replaced by Cordova\n     *\n     * @return object\n     */\n    getOriginalHandlers: function() {\n        return {'document': {'addEventListener': m_document_addEventListener, 'removeEventListener': m_document_removeEventListener},\n        'window': {'addEventListener': m_window_addEventListener, 'removeEventListener': m_window_removeEventListener}};\n    },\n    /**\n     * Method to fire event from native code\n     * bNoDetach is required for events which cause an exception which needs to be caught in native code\n     */\n    fireDocumentEvent: function(type, data, bNoDetach) {\n        var evt = createEvent(type, data);\n        if (typeof documentEventHandlers[type] != 'undefined') {\n            if( bNoDetach ) {\n                documentEventHandlers[type].fire(evt);\n            }\n            else {\n                setTimeout(function() {\n                    // Fire deviceready on listeners that were registered before cordova.js was loaded.\n                    if (type == 'deviceready') {\n                        document.dispatchEvent(evt);\n                    }\n                    documentEventHandlers[type].fire(evt);\n                }, 0);\n            }\n        } else {\n            document.dispatchEvent(evt);\n        }\n    },\n    fireWindowEvent: function(type, data) {\n        var evt = createEvent(type,data);\n        if (typeof windowEventHandlers[type] != 'undefined') {\n            setTimeout(function() {\n                windowEventHandlers[type].fire(evt);\n            }, 0);\n        } else {\n            window.dispatchEvent(evt);\n        }\n    },\n\n    /**\n     * Plugin callback mechanism.\n     */\n    // Randomize the starting callbackId to avoid collisions after refreshing or navigating.\n    // This way, it's very unlikely that any new callback would get the same callbackId as an old callback.\n    callbackId: Math.floor(Math.random() * 2000000000),\n    callbacks:  {},\n    callbackStatus: {\n        NO_RESULT: 0,\n        OK: 1,\n        CLASS_NOT_FOUND_EXCEPTION: 2,\n        ILLEGAL_ACCESS_EXCEPTION: 3,\n        INSTANTIATION_EXCEPTION: 4,\n        MALFORMED_URL_EXCEPTION: 5,\n        IO_EXCEPTION: 6,\n        INVALID_ACTION: 7,\n        JSON_EXCEPTION: 8,\n        ERROR: 9\n    },\n    /**\n     * Called by native code when returning successful result from an action.\n     */\n    callbackSuccess: function(callbackId, args) {\n        this.callbackFromNative(callbackId, true, args.status, [args.message], args.keepCallback);\n    },\n    /**\n     * Called by native code when returning error result from an action.\n     */\n    callbackError: function(callbackId, args) {\n        // TODO: Deprecate callbackSuccess and callbackError in favour of callbackFromNative.\n        // Derive success from status.\n        this.callbackFromNative(callbackId, false, args.status, [args.message], args.keepCallback);\n    },\n    /**\n     * Called by native code when returning the result from an action.\n     */\n    callbackFromNative: function(callbackId, isSuccess, status, args, keepCallback) {\n        try {\n            var callback = cordova.callbacks[callbackId];\n            if (callback) {\n                if (isSuccess && status == cordova.callbackStatus.OK) {\n                    callback.success && callback.success.apply(null, args);\n                } else if (!isSuccess) {\n                    callback.fail && callback.fail.apply(null, args);\n                }\n                /*\n                else\n                    Note, this case is intentionally not caught.\n                    this can happen if isSuccess is true, but callbackStatus is NO_RESULT\n                    which is used to remove a callback from the list without calling the callbacks\n                    typically keepCallback is false in this case\n                */\n\n                // Clear callback if not expecting any more results\n                if (!keepCallback) {\n                    delete cordova.callbacks[callbackId];\n                }\n            }\n        }\n        catch(err) {\n            var msg = \"Error in \" + (isSuccess ? \"Success\" : \"Error\") + \" callbackId: \" + callbackId + \" : \" + err;\n            console && console.log && console.log(msg);\n            this.fireWindowEvent(\"cordovacallbackerror\", { 'message': msg });\n            throw err;\n        }\n    },\n    addConstructor: function(func) {\n        channel.onCordovaReady.subscribe(function() {\n            try {\n                func();\n            } catch(e) {\n                console.log(\"Failed to run constructor: \" + e);\n            }\n        });\n    }\n};\n\nwindow.cordova = module.exports = cordova;\n\n},{\"cordova/channel\":\"cordova/channel\",\"cordova/platform\":\"cordova/platform\"}]},{},[\"cordova/plugin_list\",1]);\n"],"file":"cordova.js"}